{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u0130ndeks B\u00f6l\u00fcm 1 - A GIT Nedir? GIT\u2019in K\u0131sa Hikayesi Repository Nedir? Branch Nedir? Konfig\u00fcrasyon Nedir? Konfig\u00fcrasyon \u0130\u015flemleri Konfig\u00fcrasyon Dosyas\u0131 Temel Konfig\u00fcrasyon \u00d6\u011feleri \u00d6rnek Konfig\u00fcrasyon Dosyas\u0131 K\u0131sa Yollar: git alias B\u00f6l\u00fcm 1 - B Commit Nedir? \u0130lk Commit Commit Mesaj\u0131 Nedir? \u0130yi Bir Commit Mesaj\u0131 Nas\u0131l Olmal\u0131? Basit Kullan\u0131m \u00d6rne\u011fi \u00dc\u00e7 A\u015famal\u0131 Dosya Sistemi \u0130nteraktif Ekleme: git add -i Patch Mode\u2019da Ekleme: git add -p Repo\u2019nun Durumu: git status Log\u2019a Bak\u0131\u015f Baz\u0131 Dosyalar\u0131 Takip Etmemek: .gitignore Dosya Silmek, De\u011fi\u015ftirmek B\u00f6l\u00fcm 2 Branch\u2019lerle \u00c7al\u0131\u015fmak Branch\u2019leri Birle\u015ftirmek Branch\u2019lerin \u00c7ak\u0131\u015fmas\u0131: Conflict Branch\u2019leri Birle\u015ftirmek: rebasing * Branch Rebase S\u0131ras\u0131nda \u00c7ak\u0131\u015fma: Rebase Conflict * De\u011fi\u015fiklikleri G\u00f6r\u00fcnt\u00fclemek: git diff * Etiketlemek Nedir?: git tag * B\u00f6l\u00fcm 3 (Komple eksik) Commit\u2019leri Birle\u015ftirmek: Interactive Rebasing * Commit\u2019leri B\u00f6lmek * C\u0131mb\u0131zla Commit\u2019i Almak: Cherry Picking * Hatalar\u0131 \u0130\u015flemleri Geri Almak ya da Vazge\u00e7mek: reset revert amend * Commit\u2019e Not Eklemek * Her \u015fey Kay\u0131t Alt\u0131nda! En az 90 g\u00fcn: git reflog * B\u00f6l\u00fcm 4 (Komple eksik) Remote Kavram\u0131 Nedir? Remote\u2019larla \u00c7al\u0131\u015fmak * Kendi GIT Reponuzu Yap\u0131n! * GitHub, BitBucket ve GitLab ile \u00c7al\u0131\u015fmak * Repo i\u00e7inde Repo: git submodule * B\u00f6l\u00fcm 5 (Komple eksik) Commit \u00d6ncesi ya da Sonras\u0131 Otomasyonu: Hook\u2019lar * Bundle Nedir? * Commit\u2019inizi \u0130mzalay\u0131n * Revizyonlar\u0131 Sorgulamak * Commit\u2019leri Sorgulamak: blame * Bisect Nedir? * Yard\u0131mc\u0131 Ara\u00e7lar * Faydal\u0131 \u0130pu\u00e7lar\u0131 * * : Eksik b\u00f6l\u00fcmler...","title":"B\u00f6l\u00fcm \u0130ndeksi"},{"location":"#indeks","text":"","title":"\u0130ndeks"},{"location":"#bolum-1-a","text":"GIT Nedir? GIT\u2019in K\u0131sa Hikayesi Repository Nedir? Branch Nedir? Konfig\u00fcrasyon Nedir? Konfig\u00fcrasyon \u0130\u015flemleri Konfig\u00fcrasyon Dosyas\u0131 Temel Konfig\u00fcrasyon \u00d6\u011feleri \u00d6rnek Konfig\u00fcrasyon Dosyas\u0131 K\u0131sa Yollar: git alias","title":"B\u00f6l\u00fcm 1 - A"},{"location":"#bolum-1-b","text":"Commit Nedir? \u0130lk Commit Commit Mesaj\u0131 Nedir? \u0130yi Bir Commit Mesaj\u0131 Nas\u0131l Olmal\u0131? Basit Kullan\u0131m \u00d6rne\u011fi \u00dc\u00e7 A\u015famal\u0131 Dosya Sistemi \u0130nteraktif Ekleme: git add -i Patch Mode\u2019da Ekleme: git add -p Repo\u2019nun Durumu: git status Log\u2019a Bak\u0131\u015f Baz\u0131 Dosyalar\u0131 Takip Etmemek: .gitignore Dosya Silmek, De\u011fi\u015ftirmek","title":"B\u00f6l\u00fcm 1 - B"},{"location":"#bolum-2","text":"Branch\u2019lerle \u00c7al\u0131\u015fmak Branch\u2019leri Birle\u015ftirmek Branch\u2019lerin \u00c7ak\u0131\u015fmas\u0131: Conflict Branch\u2019leri Birle\u015ftirmek: rebasing * Branch Rebase S\u0131ras\u0131nda \u00c7ak\u0131\u015fma: Rebase Conflict * De\u011fi\u015fiklikleri G\u00f6r\u00fcnt\u00fclemek: git diff * Etiketlemek Nedir?: git tag *","title":"B\u00f6l\u00fcm 2"},{"location":"#bolum-3-komple-eksik","text":"Commit\u2019leri Birle\u015ftirmek: Interactive Rebasing * Commit\u2019leri B\u00f6lmek * C\u0131mb\u0131zla Commit\u2019i Almak: Cherry Picking * Hatalar\u0131 \u0130\u015flemleri Geri Almak ya da Vazge\u00e7mek: reset revert amend * Commit\u2019e Not Eklemek * Her \u015fey Kay\u0131t Alt\u0131nda! En az 90 g\u00fcn: git reflog *","title":"B\u00f6l\u00fcm 3 (Komple eksik)"},{"location":"#bolum-4-komple-eksik","text":"Remote Kavram\u0131 Nedir? Remote\u2019larla \u00c7al\u0131\u015fmak * Kendi GIT Reponuzu Yap\u0131n! * GitHub, BitBucket ve GitLab ile \u00c7al\u0131\u015fmak * Repo i\u00e7inde Repo: git submodule *","title":"B\u00f6l\u00fcm 4 (Komple eksik)"},{"location":"#bolum-5-komple-eksik","text":"Commit \u00d6ncesi ya da Sonras\u0131 Otomasyonu: Hook\u2019lar * Bundle Nedir? * Commit\u2019inizi \u0130mzalay\u0131n * Revizyonlar\u0131 Sorgulamak * Commit\u2019leri Sorgulamak: blame * Bisect Nedir? * Yard\u0131mc\u0131 Ara\u00e7lar * Faydal\u0131 \u0130pu\u00e7lar\u0131 * * : Eksik b\u00f6l\u00fcmler...","title":"B\u00f6l\u00fcm 5 (Komple eksik)"},{"location":"acknowledgements/","text":"Te\u015fekk\u00fcrler Yaz\u0131m ve imla hatalar\u0131n\u0131 d\u00fczeltmek yoluyla katk\u0131da bulunan herkese \u00e7ok te\u015fekk\u00fcr ederim. \u0130simler alfabetik olarak s\u0131raya g\u00f6re dizilmi\u015ftir. An\u0131l \u0130yido\u011fan Ekrem Candemir Ka\u011fan Utku K\u0131l\u0131\u00e7l\u0131 Mustafa Enes G\u00fcneruz P\u0131nar Tekir Do\u011fan Zafer \u00c7elenk","title":"Te\u015fekk\u00fcrler"},{"location":"acknowledgements/#tesekkurler","text":"Yaz\u0131m ve imla hatalar\u0131n\u0131 d\u00fczeltmek yoluyla katk\u0131da bulunan herkese \u00e7ok te\u015fekk\u00fcr ederim. \u0130simler alfabetik olarak s\u0131raya g\u00f6re dizilmi\u015ftir. An\u0131l \u0130yido\u011fan Ekrem Candemir Ka\u011fan Utku K\u0131l\u0131\u00e7l\u0131 Mustafa Enes G\u00fcneruz P\u0131nar Tekir Do\u011fan Zafer \u00c7elenk","title":"Te\u015fekk\u00fcrler"},{"location":"cover/","text":"","title":"Kapak"},{"location":"preface/","text":"\u00d6ns\u00f6z @wip","title":"\u00d6ns\u00f6z"},{"location":"preface/#onsoz","text":"@wip","title":"\u00d6ns\u00f6z"},{"location":"technical-review/","text":"Teknik Ele\u015ftiri / \u0130nceleme Bu k\u0131s\u0131m, okudu\u011fum yabanc\u0131 kitaplar\u0131n ( teknik konular, yaz\u0131l\u0131m geli\u015ftirme ve benzeri ) \u00e7o\u011funda g\u00f6rd\u00fc\u011f\u00fcm ama ne yaz\u0131kki bizim yay\u0131n-evleri ya da yazarlar\u0131m\u0131z\u0131n pek de yapmad\u0131\u011f\u0131 k\u0131s\u0131m. Techinal Review yani ilgili konunun uzman\u0131 ya da sekt\u00f6r profesyoneli taraf\u0131ndan yap\u0131lan yorum. Bunun \u00e7ok \u00f6nemli oldu\u011funu d\u00fc\u015f\u00fcn\u00fcyorum. Neden mi? Acaba ger\u00e7ekten konuyu do\u011fru anlam\u0131\u015f ve anlatm\u0131\u015fm\u0131y\u0131m? Yazd\u0131klar\u0131m aras\u0131nda tutars\u0131zl\u0131klar var m\u0131? Verdi\u011fim \u00f6rnekler do\u011fru mu? Ya da anlatt\u0131\u011f\u0131m konu ile ilgili mi? Hangi k\u0131s\u0131mlar\u0131 teknik anlamda d\u00fczeltmek gerek? sonu\u00e7 olarak bu kitap ger\u00e7ekten amac\u0131na hizmet etsin istiyorum. Ele\u015ftirmenler @wip","title":"Teknik \u0130ncleme"},{"location":"technical-review/#teknik-elestiri-inceleme","text":"Bu k\u0131s\u0131m, okudu\u011fum yabanc\u0131 kitaplar\u0131n ( teknik konular, yaz\u0131l\u0131m geli\u015ftirme ve benzeri ) \u00e7o\u011funda g\u00f6rd\u00fc\u011f\u00fcm ama ne yaz\u0131kki bizim yay\u0131n-evleri ya da yazarlar\u0131m\u0131z\u0131n pek de yapmad\u0131\u011f\u0131 k\u0131s\u0131m. Techinal Review yani ilgili konunun uzman\u0131 ya da sekt\u00f6r profesyoneli taraf\u0131ndan yap\u0131lan yorum. Bunun \u00e7ok \u00f6nemli oldu\u011funu d\u00fc\u015f\u00fcn\u00fcyorum. Neden mi? Acaba ger\u00e7ekten konuyu do\u011fru anlam\u0131\u015f ve anlatm\u0131\u015fm\u0131y\u0131m? Yazd\u0131klar\u0131m aras\u0131nda tutars\u0131zl\u0131klar var m\u0131? Verdi\u011fim \u00f6rnekler do\u011fru mu? Ya da anlatt\u0131\u011f\u0131m konu ile ilgili mi? Hangi k\u0131s\u0131mlar\u0131 teknik anlamda d\u00fczeltmek gerek? sonu\u00e7 olarak bu kitap ger\u00e7ekten amac\u0131na hizmet etsin istiyorum.","title":"Teknik Ele\u015ftiri / \u0130nceleme"},{"location":"technical-review/#elestirmenler","text":"@wip","title":"Ele\u015ftirmenler"},{"location":"bolum-01/01-git-nedir/","text":"GIT Nedir? E\u011fer komut sat\u0131r\u0131ndan man git derseniz, kar\u015f\u0131n\u0131za \u00e7\u0131kacak olan man page\u2019de: NAME git - the stupid content tracker ifadesini g\u00f6r\u00fcrs\u00fcn\u00fcz. the stupid content tracker yani: aptal i\u00e7erik takip\u00e7isi. Biraz ilgin\u00e7 de\u011fil mi? Yaz\u0131l\u0131m d\u00fcnyas\u0131nda Microsoft\u2019undan Apple\u2019\u0131na Google\u2019\u0131na kadar neredeyse 7\u2019den 70\u2019e kulland\u0131\u011f\u0131m\u0131z bir ara\u00e7 var ve ad\u0131: aptal i\u00e7erik takip\u00e7isi... GIT asl\u0131nda, da\u011f\u0131t\u0131k \u00e7al\u0131\u015fan s\u00fcr\u00fcm kontrol sistemi ( DVCS ) ve kaynak kod y\u00f6netim ( SCM ) arac\u0131d\u0131r. DVCS: D istributed V ersion C ontrol S ystem, SCM: S ource C ode M anagement anlam\u0131na gelir. E\u015fde\u011fer di\u011fer ara\u00e7lardan \u00f6ne \u00e7\u0131kan farklar\u0131 ise; Herhangi bir merkez sunucuya ihtiya\u00e7 duymadan, offline olarak \u00e7al\u0131\u015fabilmesi G\u00fcvenilirlik, commit \u2019lerin tekil olmas\u0131 1 H\u0131zl\u0131 olmas\u0131 2 Az yer tutmas\u0131 S\u0131f\u0131r maliyetle branching ( dallanma ) yapabilmek ve merge etmek ( birle\u015ftirebilmek ) Deployment ve benzeri i\u015fler i\u00e7in de kullan\u0131lmas\u0131. Bu g\u00fczel tool, Linux\u2019un \u00e7ekirde\u011fini yazan Linus Torvalds taraf\u0131ndan geli\u015ftirilmi\u015f ve a\u00e7\u0131k-kaynak \u015feklinde da\u011f\u0131t\u0131lm\u0131\u015ft\u0131r. T\u00fcm kaynak kod GitHub \u2019da durmaktad\u0131r. Bu kitab\u0131 yazd\u0131\u011f\u0131m an itibariyle akt\u00fcel olan versiyon: 2.13.1 Mart 2017 itibariyle biraz can s\u0131k\u0131c\u0131 bir durumla kar\u015f\u0131la\u015ft\u0131 GIT kullan\u0131c\u0131lar\u0131. \u21a9 Facebook / Google ve benzeri \u00f6l\u00e7eklerde projelerde ( gigabyte\u2019larca ) baz\u0131 i\u015flemler \u00e7ok yava\u015fl\u0131yormu\u015f. \u21a9","title":"GIT Nedir?"},{"location":"bolum-01/01-git-nedir/#git-nedir","text":"E\u011fer komut sat\u0131r\u0131ndan man git derseniz, kar\u015f\u0131n\u0131za \u00e7\u0131kacak olan man page\u2019de: NAME git - the stupid content tracker ifadesini g\u00f6r\u00fcrs\u00fcn\u00fcz. the stupid content tracker yani: aptal i\u00e7erik takip\u00e7isi. Biraz ilgin\u00e7 de\u011fil mi? Yaz\u0131l\u0131m d\u00fcnyas\u0131nda Microsoft\u2019undan Apple\u2019\u0131na Google\u2019\u0131na kadar neredeyse 7\u2019den 70\u2019e kulland\u0131\u011f\u0131m\u0131z bir ara\u00e7 var ve ad\u0131: aptal i\u00e7erik takip\u00e7isi... GIT asl\u0131nda, da\u011f\u0131t\u0131k \u00e7al\u0131\u015fan s\u00fcr\u00fcm kontrol sistemi ( DVCS ) ve kaynak kod y\u00f6netim ( SCM ) arac\u0131d\u0131r. DVCS: D istributed V ersion C ontrol S ystem, SCM: S ource C ode M anagement anlam\u0131na gelir. E\u015fde\u011fer di\u011fer ara\u00e7lardan \u00f6ne \u00e7\u0131kan farklar\u0131 ise; Herhangi bir merkez sunucuya ihtiya\u00e7 duymadan, offline olarak \u00e7al\u0131\u015fabilmesi G\u00fcvenilirlik, commit \u2019lerin tekil olmas\u0131 1 H\u0131zl\u0131 olmas\u0131 2 Az yer tutmas\u0131 S\u0131f\u0131r maliyetle branching ( dallanma ) yapabilmek ve merge etmek ( birle\u015ftirebilmek ) Deployment ve benzeri i\u015fler i\u00e7in de kullan\u0131lmas\u0131. Bu g\u00fczel tool, Linux\u2019un \u00e7ekirde\u011fini yazan Linus Torvalds taraf\u0131ndan geli\u015ftirilmi\u015f ve a\u00e7\u0131k-kaynak \u015feklinde da\u011f\u0131t\u0131lm\u0131\u015ft\u0131r. T\u00fcm kaynak kod GitHub \u2019da durmaktad\u0131r. Bu kitab\u0131 yazd\u0131\u011f\u0131m an itibariyle akt\u00fcel olan versiyon: 2.13.1 Mart 2017 itibariyle biraz can s\u0131k\u0131c\u0131 bir durumla kar\u015f\u0131la\u015ft\u0131 GIT kullan\u0131c\u0131lar\u0131. \u21a9 Facebook / Google ve benzeri \u00f6l\u00e7eklerde projelerde ( gigabyte\u2019larca ) baz\u0131 i\u015flemler \u00e7ok yava\u015fl\u0131yormu\u015f. \u21a9","title":"GIT Nedir?"},{"location":"bolum-01/02-gitin-kisa-hikayesi/","text":"GIT\u2019in Hikayesi Linus Torvalds , 2002 y\u0131l\u0131nda, kernel\u2019i geli\u015ftirirken BitKeeper adl\u0131 revizyon kontrol sistemini kullan\u0131yor. 2005 y\u0131l\u0131nda Linux kernel geli\u015ftirici toplulu\u011fu ile BitKeeper aras\u0131nda bir s\u0131k\u0131nt\u0131 oluyor. BitKeeper\u2019\u0131n \u00fccretsiz kullan\u0131m lisans\u0131 iptal oluyor ve Linus\u2019un sigorta bu noktada at\u0131yor . \u0130zledi\u011fim Git Under the Hood e\u011fitiminde Jeffrey Haemer , Linus\u2019un GIT\u2019i geli\u015ftirmeye bir pazartesi ba\u015flay\u0131p, \u00e7ar\u015famba g\u00fcn\u00fcnden itibaren GIT\u2019i GIT ile versiyonlamaya ba\u015flad\u0131\u011f\u0131n\u0131 s\u00f6yledi. Bu kadar h\u0131zl\u0131 geli\u015ftirmesinin sebebi olarak da zaten \u00e7ok iyi bildi\u011fi kernel\u2019i kopyalamas\u0131 oldu\u011funu s\u00f6yledi. Hatta Ken Thompson \u2019\u0131n da Unix\u2019i tam 1 ay da yazd\u0131\u011f\u0131n\u0131, Linus\u2019un da Unix\u2019i \u00f6rnek ald\u0131\u011f\u0131n\u0131 s\u00f6yledi... Sonu\u00e7 Olarak... Neticede GIT asl\u0131nda bir veritaban\u0131 d\u0131r. Tan\u0131mland\u0131\u011f\u0131 dizin alt\u0131nda \u00e7al\u0131\u015fan, ilgili bilgilerini, ayarlar\u0131n\u0131 ve benzeri bilgilerini .git/ dizini alt\u0131nda tutan, o dizindeki t\u00fcm dosyalar\u0131n ( e\u011fer izole edilmemi\u015fse ) versiyonlar\u0131n\u0131 yani dosyalardaki de\u011fi\u015fikliklerin tarih\u00e7esini, bu kendi \u015fahs\u0131na \u00f6zel veritaban\u0131 mekanizmas\u0131 i\u00e7inde saklar.","title":"GIT\u2019in K\u0131sa Hikayesi"},{"location":"bolum-01/02-gitin-kisa-hikayesi/#gitin-hikayesi","text":"Linus Torvalds , 2002 y\u0131l\u0131nda, kernel\u2019i geli\u015ftirirken BitKeeper adl\u0131 revizyon kontrol sistemini kullan\u0131yor. 2005 y\u0131l\u0131nda Linux kernel geli\u015ftirici toplulu\u011fu ile BitKeeper aras\u0131nda bir s\u0131k\u0131nt\u0131 oluyor. BitKeeper\u2019\u0131n \u00fccretsiz kullan\u0131m lisans\u0131 iptal oluyor ve Linus\u2019un sigorta bu noktada at\u0131yor . \u0130zledi\u011fim Git Under the Hood e\u011fitiminde Jeffrey Haemer , Linus\u2019un GIT\u2019i geli\u015ftirmeye bir pazartesi ba\u015flay\u0131p, \u00e7ar\u015famba g\u00fcn\u00fcnden itibaren GIT\u2019i GIT ile versiyonlamaya ba\u015flad\u0131\u011f\u0131n\u0131 s\u00f6yledi. Bu kadar h\u0131zl\u0131 geli\u015ftirmesinin sebebi olarak da zaten \u00e7ok iyi bildi\u011fi kernel\u2019i kopyalamas\u0131 oldu\u011funu s\u00f6yledi. Hatta Ken Thompson \u2019\u0131n da Unix\u2019i tam 1 ay da yazd\u0131\u011f\u0131n\u0131, Linus\u2019un da Unix\u2019i \u00f6rnek ald\u0131\u011f\u0131n\u0131 s\u00f6yledi... Sonu\u00e7 Olarak... Neticede GIT asl\u0131nda bir veritaban\u0131 d\u0131r. Tan\u0131mland\u0131\u011f\u0131 dizin alt\u0131nda \u00e7al\u0131\u015fan, ilgili bilgilerini, ayarlar\u0131n\u0131 ve benzeri bilgilerini .git/ dizini alt\u0131nda tutan, o dizindeki t\u00fcm dosyalar\u0131n ( e\u011fer izole edilmemi\u015fse ) versiyonlar\u0131n\u0131 yani dosyalardaki de\u011fi\u015fikliklerin tarih\u00e7esini, bu kendi \u015fahs\u0131na \u00f6zel veritaban\u0131 mekanizmas\u0131 i\u00e7inde saklar.","title":"GIT\u2019in Hikayesi"},{"location":"bolum-01/03-repository-nedir/","text":"Repository ya da Repo Nedir? Revizyon kontrol\u00fc alt\u0131ndaki dizin bir Repository\u2019dir. S\u00f6zl\u00fck anlam\u0131na bakt\u0131\u011f\u0131n\u0131zda; depo , dolap , kutu , kap gibi kar\u015f\u0131l\u0131\u011f\u0131 oldu\u011funu g\u00f6r\u00fcrs\u00fcn\u00fcz. Bence tam anlam\u0131yla i\u00e7inde dosyalar\u0131n ( daha do\u011frusu kaynak kodlar\u0131n ) bulundu\u011fu bir depodur Repository. Halk aras\u0131nda k\u0131saca Repo olarak kullan\u0131l\u0131r. Film sekt\u00f6r\u00fcnde \u00e7al\u0131\u015fan biri i\u00e7in Repo tatil anlam\u0131na geldi\u011fi gibi finans / bankac\u0131l\u0131k sekt\u00f6r\u00fcnde de gecelik repo gibi faiz i\u00e7erikli anlamlar\u0131 da bulunur. E\u011fer bilgisayar\u0131n\u0131zda GIT kuruluysa; $ git --version $ git help gibi komutlar\u0131n \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 g\u00f6receksiniz. E\u011fer yukar\u0131daki komutlar \u00e7al\u0131\u015fm\u0131yorsa, kulland\u0131\u011f\u0131n\u0131z i\u015fletim sistemine g\u00f6re; bu link yard\u0131m\u0131yla GIT\u2019i indirebilir ve kurabilirsiniz. GIT, i\u00e7inde harika bir dok\u00fcmantasyon ile geliyor. Kullanaca\u011f\u0131n\u0131z komut hakk\u0131nda bilgi almak \u00e7ok kolay: $ git help commit $ git help status $ git help clone # git help KOMUT H\u0131zl\u0131ca repository olu\u015fturmak i\u00e7in iki y\u00f6ntem var; ilk y\u00f6ntem, bir dizin olu\u015fturup, i\u00e7ine girip repoyu olu\u015fturmak: git init $ mkdir proje $ cd proje/ $ git init Initialized empty Git repository in /private/tmp/proje/.git/ GIT bize bo\u015f bir repository olu\u015fturdu\u011funu s\u00f6yler. Di\u011fer y\u00f6ntem ise tek sat\u0131rda; $ git init proje Initialized empty Git repository in /private/tmp/proje/.git/ i\u015fi halletmektir. \u00d6rnekleri kendi bilgisayar\u0131mda /tmp/ yani temporary / ge\u00e7ici dizinde yapmaktay\u0131m. Bu bak\u0131mdan g\u00f6rd\u00fc\u011f\u00fcn\u00fcz /private/tmp/proje/ gibi dizinler sizi \u015fa\u015f\u0131rtmas\u0131n! Tamam, repo olu\u015ftu. Peki sonra ? Bence en \u00e7ok kullan\u0131lan komutlardan biri olan git status ile tan\u0131\u015fal\u0131m. $ git status On branch main No commits yet nothing to commit ( create/copy files and use \"git add\" to track ) git status ile o anki durumu g\u00f6r\u00fcnt\u00fcl\u00fcyoruz. An itibariyle master branch\u2019deyiz, commit edecek hi\u00e7bir \u015fey yok. Bu durumda kar\u015f\u0131m\u0131zda iki tane yeni kavram var. branch ve commit . 19 A\u011fustos 2021 Ge\u00e7ti\u011fimiz y\u0131llarda master ve slave adland\u0131rmalar\u0131 \u0131rk\u00e7\u0131 s\u00f6ylem \u00e7a\u011fr\u0131\u015ft\u0131rd\u0131\u011f\u0131 gerek\u00e7esiyle, pek \u00e7ok platformda bu tan\u0131mlar de\u011fi\u015ftirildi. Git default branch\u2019i otomatik olarak main ismiyle a\u00e7abilmemiz i\u00e7in config dosyas\u0131na ek getirdi: [init] defaultBranch = main ya da; $ git config --global init.defaultBranch main \u015feklinde ayarlayabilirsiniz. Keza GitHub\u2019da da otomatik olarak a\u00e7\u0131lan her yeni repo main default branch\u2019ine sahip oluyor.","title":"Repository Nedir?"},{"location":"bolum-01/03-repository-nedir/#repository-ya-da-repo-nedir","text":"Revizyon kontrol\u00fc alt\u0131ndaki dizin bir Repository\u2019dir. S\u00f6zl\u00fck anlam\u0131na bakt\u0131\u011f\u0131n\u0131zda; depo , dolap , kutu , kap gibi kar\u015f\u0131l\u0131\u011f\u0131 oldu\u011funu g\u00f6r\u00fcrs\u00fcn\u00fcz. Bence tam anlam\u0131yla i\u00e7inde dosyalar\u0131n ( daha do\u011frusu kaynak kodlar\u0131n ) bulundu\u011fu bir depodur Repository. Halk aras\u0131nda k\u0131saca Repo olarak kullan\u0131l\u0131r. Film sekt\u00f6r\u00fcnde \u00e7al\u0131\u015fan biri i\u00e7in Repo tatil anlam\u0131na geldi\u011fi gibi finans / bankac\u0131l\u0131k sekt\u00f6r\u00fcnde de gecelik repo gibi faiz i\u00e7erikli anlamlar\u0131 da bulunur. E\u011fer bilgisayar\u0131n\u0131zda GIT kuruluysa; $ git --version $ git help gibi komutlar\u0131n \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 g\u00f6receksiniz. E\u011fer yukar\u0131daki komutlar \u00e7al\u0131\u015fm\u0131yorsa, kulland\u0131\u011f\u0131n\u0131z i\u015fletim sistemine g\u00f6re; bu link yard\u0131m\u0131yla GIT\u2019i indirebilir ve kurabilirsiniz. GIT, i\u00e7inde harika bir dok\u00fcmantasyon ile geliyor. Kullanaca\u011f\u0131n\u0131z komut hakk\u0131nda bilgi almak \u00e7ok kolay: $ git help commit $ git help status $ git help clone # git help KOMUT H\u0131zl\u0131ca repository olu\u015fturmak i\u00e7in iki y\u00f6ntem var; ilk y\u00f6ntem, bir dizin olu\u015fturup, i\u00e7ine girip repoyu olu\u015fturmak: git init $ mkdir proje $ cd proje/ $ git init Initialized empty Git repository in /private/tmp/proje/.git/ GIT bize bo\u015f bir repository olu\u015fturdu\u011funu s\u00f6yler. Di\u011fer y\u00f6ntem ise tek sat\u0131rda; $ git init proje Initialized empty Git repository in /private/tmp/proje/.git/ i\u015fi halletmektir. \u00d6rnekleri kendi bilgisayar\u0131mda /tmp/ yani temporary / ge\u00e7ici dizinde yapmaktay\u0131m. Bu bak\u0131mdan g\u00f6rd\u00fc\u011f\u00fcn\u00fcz /private/tmp/proje/ gibi dizinler sizi \u015fa\u015f\u0131rtmas\u0131n! Tamam, repo olu\u015ftu. Peki sonra ? Bence en \u00e7ok kullan\u0131lan komutlardan biri olan git status ile tan\u0131\u015fal\u0131m. $ git status On branch main No commits yet nothing to commit ( create/copy files and use \"git add\" to track ) git status ile o anki durumu g\u00f6r\u00fcnt\u00fcl\u00fcyoruz. An itibariyle master branch\u2019deyiz, commit edecek hi\u00e7bir \u015fey yok. Bu durumda kar\u015f\u0131m\u0131zda iki tane yeni kavram var. branch ve commit . 19 A\u011fustos 2021 Ge\u00e7ti\u011fimiz y\u0131llarda master ve slave adland\u0131rmalar\u0131 \u0131rk\u00e7\u0131 s\u00f6ylem \u00e7a\u011fr\u0131\u015ft\u0131rd\u0131\u011f\u0131 gerek\u00e7esiyle, pek \u00e7ok platformda bu tan\u0131mlar de\u011fi\u015ftirildi. Git default branch\u2019i otomatik olarak main ismiyle a\u00e7abilmemiz i\u00e7in config dosyas\u0131na ek getirdi: [init] defaultBranch = main ya da; $ git config --global init.defaultBranch main \u015feklinde ayarlayabilirsiniz. Keza GitHub\u2019da da otomatik olarak a\u00e7\u0131lan her yeni repo main default branch\u2019ine sahip oluyor.","title":"Repository ya da Repo Nedir?"},{"location":"bolum-01/04-branch-nedir/","text":"Branch Nedir? \u0130stedi\u011finiz bir anda, elinizdeki koddan h\u0131zl\u0131ca bir ya da N tane kopya \u00e7\u0131kartma i\u015flemidir. Yerel bir operasyondur. Yani yapt\u0131\u011f\u0131n\u0131z her branch , siz payla\u015fmad\u0131k\u00e7a sadece sizde bulunur. Daha teknik bir anlat\u0131mla branch asl\u0131nda i\u00e7inde commit-id yazan bir i\u015faret\u00e7iden ba\u015fka bir \u015fey de\u011fildir. git , s\u0131f\u0131r bir repository olu\u015fturuldu\u011funda, aksi belirtilmedik\u00e7e, varsay\u0131lan ( default ) branch olarak main branch\u2019i olu\u015fturur. Eskiden bu default olarak master \u2019d\u0131. $ git init proje Initialized empty Git repository in /private/tmp/proje/.git/ $ cd proje/ $ git status On branch main No commits yet nothing to commit ( create/copy files and use \"git add\" to track ) \u015fu an main branch\u2019deyiz ( eskiden master\u2019d\u0131 ) ve commit edecek hi\u00e7bir \u015fey yok...","title":"Branch Nedir?"},{"location":"bolum-01/04-branch-nedir/#branch-nedir","text":"\u0130stedi\u011finiz bir anda, elinizdeki koddan h\u0131zl\u0131ca bir ya da N tane kopya \u00e7\u0131kartma i\u015flemidir. Yerel bir operasyondur. Yani yapt\u0131\u011f\u0131n\u0131z her branch , siz payla\u015fmad\u0131k\u00e7a sadece sizde bulunur. Daha teknik bir anlat\u0131mla branch asl\u0131nda i\u00e7inde commit-id yazan bir i\u015faret\u00e7iden ba\u015fka bir \u015fey de\u011fildir. git , s\u0131f\u0131r bir repository olu\u015fturuldu\u011funda, aksi belirtilmedik\u00e7e, varsay\u0131lan ( default ) branch olarak main branch\u2019i olu\u015fturur. Eskiden bu default olarak master \u2019d\u0131. $ git init proje Initialized empty Git repository in /private/tmp/proje/.git/ $ cd proje/ $ git status On branch main No commits yet nothing to commit ( create/copy files and use \"git add\" to track ) \u015fu an main branch\u2019deyiz ( eskiden master\u2019d\u0131 ) ve commit edecek hi\u00e7bir \u015fey yok...","title":"Branch Nedir?"},{"location":"bolum-01/05-konfigurasyon-nedir/","text":"Konfig\u00fcrasyon Nedir? 3 kapsaml\u0131 konfig\u00fcrasyon bulunur: Local Sadece i\u00e7inde bulundu\u011funuz ( dizin ) repository i\u00e7in ge\u00e7erlidir. Ki\u015fisel projelerinizde ki\u015fisel e-posta adresi kullan\u0131rken, \u015firket projelerinde \u015firket taraf\u0131ndan verilen e-posta adresini kullanman\u0131z gerekebilir. Global Bilgisayara giri\u015f yapm\u0131\u015f ( login olmu\u015f ) kullan\u0131c\u0131n\u0131n eri\u015fim yetkisi olan t\u00fcm repository\u2019ler i\u00e7in ge\u00e7erlidir. De\u011fer atarken --global anahtar kelimesi kullan\u0131l\u0131r. System Bilgisayardaki t\u00fcm kullan\u0131c\u0131lar\u0131 etkileyen en \u00fcst seviyedeki konfig\u00fcrasyondur. De\u011fer atarken --system anahtar kelimesi kullan\u0131l\u0131r. Konfig\u00fcrasyon ayarlar\u0131n\u0131 yapmak i\u00e7in; git config komutunu kullan\u0131r\u0131z. \u0130lk GIT kurulumunda olmazsa olmaz olan iki tane konfig\u00fcrasyon \u00f6\u011fesi bulunur: user.name user.email","title":"Konfig\u00fcrasyon Nedir?"},{"location":"bolum-01/05-konfigurasyon-nedir/#konfigurasyon-nedir","text":"3 kapsaml\u0131 konfig\u00fcrasyon bulunur:","title":"Konfig\u00fcrasyon Nedir?"},{"location":"bolum-01/05-konfigurasyon-nedir/#local","text":"Sadece i\u00e7inde bulundu\u011funuz ( dizin ) repository i\u00e7in ge\u00e7erlidir. Ki\u015fisel projelerinizde ki\u015fisel e-posta adresi kullan\u0131rken, \u015firket projelerinde \u015firket taraf\u0131ndan verilen e-posta adresini kullanman\u0131z gerekebilir.","title":"Local"},{"location":"bolum-01/05-konfigurasyon-nedir/#global","text":"Bilgisayara giri\u015f yapm\u0131\u015f ( login olmu\u015f ) kullan\u0131c\u0131n\u0131n eri\u015fim yetkisi olan t\u00fcm repository\u2019ler i\u00e7in ge\u00e7erlidir. De\u011fer atarken --global anahtar kelimesi kullan\u0131l\u0131r.","title":"Global"},{"location":"bolum-01/05-konfigurasyon-nedir/#system","text":"Bilgisayardaki t\u00fcm kullan\u0131c\u0131lar\u0131 etkileyen en \u00fcst seviyedeki konfig\u00fcrasyondur. De\u011fer atarken --system anahtar kelimesi kullan\u0131l\u0131r. Konfig\u00fcrasyon ayarlar\u0131n\u0131 yapmak i\u00e7in; git config komutunu kullan\u0131r\u0131z. \u0130lk GIT kurulumunda olmazsa olmaz olan iki tane konfig\u00fcrasyon \u00f6\u011fesi bulunur: user.name user.email","title":"System"},{"location":"bolum-01/06-konfigurasyon-islemleri/","text":"Konfig\u00fcrasyon \u0130\u015flemleri Sonu\u00e7 olarak konfig\u00fcrasyon dosyas\u0131 ad\u0131 \u00fczerinde bir dosya. Herhangi bir text edit\u00f6r ile a\u00e7\u0131p d\u00fczenleyebilirsiniz. En h\u0131zl\u0131 ve kolay yolu bu. Bunun d\u0131\u015f\u0131nda, git config komutuna \u00e7e\u015fitli parametreler ge\u00e7erek de\u011ferleri sorgulayabilir, silebilir, d\u00fczeltebilirsiniz. \u00c7ok daha fazla detay i\u00e7in t\u0131klay\u0131n . Comment Out ( Yorum ) Bu dosyada comment out yani programlama dillerindeki gibi yorum sat\u0131r\u0131 ya da bazen bir \u015feyleri denemek i\u00e7in anl\u0131k sat\u0131r\u0131 off etmek i\u00e7in pop\u00fcler programlama dillerinden al\u0131\u015fk\u0131n oldu\u011fumuz # ve ; kullan\u0131lm\u0131\u015f: # bu # yorum # sat\u0131r\u0131 ; bu ; sat\u0131r da yorum... [user] name = U\u011fur \u00d6zy\u0131lmazel De\u011fer Okumak: --get \u00d6rne\u011fin core grubu alt\u0131nda bulunan filemode de\u011fi\u015fkeninin de\u011ferini; $ git config --get core.filemode true --get GRUP.DE\u011e\u0130\u015eKEN \u015feklinde okuruz. Asl\u0131nda --get opsiyonel. Yani yazmak zorunda de\u011filsiniz: $ git config user.name U\u011fur \u00d6zy\u0131lmazel Ben homebrew \u2019la beraber bash-completion paketini de kulland\u0131\u011f\u0131m i\u00e7in, pek \u00e7ok GIT i\u015flemini auto-complete ya da tab-completion ya da otomatik olarak TAB tu\u015funa bas\u0131nca tamamlama ile kullan\u0131yorum. \u0130\u015flerim s\u00fcper kolayla\u015f\u0131yor ve daha az \u015fey ezberlemek durumunda kal\u0131yorum. 19 A\u011fustos 2021 Mutlaka tavsiye ederim: $ brew install git-extras Linux t\u00fcrevleri genelde GIT paketini kurunca otomatik olarak bu tamamlamay\u0131 da beraberinde getiriyor. De\u011feri Silmek: --unset \u015eimdi denemek i\u00e7in kullan\u0131c\u0131 seviyesinde de\u011fer atamas\u0131 yapal\u0131m: $ git config --global alias.s status bu komut ile k\u0131sa yol tan\u0131mlad\u0131k. art\u0131k git status yerine git s yapmak yeterli. Bu alias konusuna ileride daha detayl\u0131 girece\u011fiz. \u015eimdi bu k\u0131sa yolu silmek i\u00e7in: $ git config --global --unset alias.s yapmak yeterli. include ve includeIf Yan\u0131lm\u0131yorsam GIT versiyon 2.10+ ile gelen, benim \u00e7ok sevdi\u011fim hayat\u0131m\u0131 kolayla\u015ft\u0131ran 2 direktif. Benim gibi evde ki\u015fisel bilgisayar, i\u015fte ofis bilgisayar\u0131 kullan\u0131yorsan\u0131z asl\u0131nda 2 farkl\u0131 insan gibisiniz. Belki birden fazla bilgisayar\u0131n\u0131z var. Duruma g\u00f6re her bilgisayar\u0131n \u00f6zel bir konfig\u00fcrasyon direktifine ihtiyac\u0131 olabilir. Ya da sadece belli dizinlerin alt\u0131nda belli ayarlar \u00e7al\u0131\u015fsa? Her bilgisayarda ortak ~/.gitconfig dosyas\u0131n\u0131 kullanmak ama bilgisayar\u0131na g\u00f6re ayar yapmak istiyordum. \u0130\u015fte bu durumda imdad\u0131ma include yeti\u015fti. [include] path = ~/.gitlocalconfig ~/.gitlocalconfig bu dosya her iki bilgisayar\u0131mda da bulunuyor. Ana GIT konfig\u00fcrasyon dosyamda user grubunda name ve email ayarlar\u0131 var. Farkl\u0131 bilgisayarlarda farkl\u0131 GPG anahtarlar\u0131 kulland\u0131\u011f\u0131m i\u00e7in ( bunun ne oldu\u011funu ileride anlataca\u011f\u0131m ) user.signingkey de\u011feri her makine i\u00e7in farkl\u0131 :) E\u011fer bulundu\u011fum dizin ~/Dev/Amiga/Bronx-Sources/ ise ~/.gitconfig-bronx-repos konfig\u00fcrasyon dosyas\u0131n\u0131 kullan demek istiyorum. Nas\u0131l m\u0131? [includeIf \"gitdir:~/Dev/Amiga/Bronx-Sources/\"] path = ~/.gitconfig-bronx-repos Bu dosyada yani ~/.gitconfig-bronx-repos dosyas\u0131nda ne mi var? [user] name = vigo/bronx email = vigo@bronx....org signingkey = D3M(O)(SC/\\/3) yani ben ne zaman cd ~/Dev/Amiga/Bronx-Sources/ yap\u0131p, bu dizin alt\u0131nda bulunan herhangi bir repoda i\u015flem yapacak olursam, yukar\u0131daki de\u011ferler aktif olacak! Bana \u015fu soruyu sorabilirsiniz: Neden Local olarak ayar yapmad\u0131n? \u0130lgili dizin alt\u0131n 300 tane repo olsa? tek-tek dizinlerin alt\u0131na gidip git config yapmak zorunda kalmak iyi bir fikir mi? Son olarak path = dosya mant\u0131\u011f\u0131nda birden fazla path tan\u0131mlamak m\u00fcmk\u00fcn: [include] path = ~/.git-localconfig-1 path = ~/.git-localconfig-2 path = ~/.git-localconfig-3 [includeIf \"gitdir:~/Dev/C64/Zombie-Boys-Sources/\"] path = ~/.git-zb-config-1 path = ~/.git-zb-config-2 gibi...","title":"Konfig\u00fcrasyon \u0130\u015flemleri"},{"location":"bolum-01/06-konfigurasyon-islemleri/#konfigurasyon-islemleri","text":"Sonu\u00e7 olarak konfig\u00fcrasyon dosyas\u0131 ad\u0131 \u00fczerinde bir dosya. Herhangi bir text edit\u00f6r ile a\u00e7\u0131p d\u00fczenleyebilirsiniz. En h\u0131zl\u0131 ve kolay yolu bu. Bunun d\u0131\u015f\u0131nda, git config komutuna \u00e7e\u015fitli parametreler ge\u00e7erek de\u011ferleri sorgulayabilir, silebilir, d\u00fczeltebilirsiniz. \u00c7ok daha fazla detay i\u00e7in t\u0131klay\u0131n .","title":"Konfig\u00fcrasyon \u0130\u015flemleri"},{"location":"bolum-01/06-konfigurasyon-islemleri/#comment-out-yorum","text":"Bu dosyada comment out yani programlama dillerindeki gibi yorum sat\u0131r\u0131 ya da bazen bir \u015feyleri denemek i\u00e7in anl\u0131k sat\u0131r\u0131 off etmek i\u00e7in pop\u00fcler programlama dillerinden al\u0131\u015fk\u0131n oldu\u011fumuz # ve ; kullan\u0131lm\u0131\u015f: # bu # yorum # sat\u0131r\u0131 ; bu ; sat\u0131r da yorum... [user] name = U\u011fur \u00d6zy\u0131lmazel","title":"Comment Out (Yorum)"},{"location":"bolum-01/06-konfigurasyon-islemleri/#deger-okumak-get","text":"\u00d6rne\u011fin core grubu alt\u0131nda bulunan filemode de\u011fi\u015fkeninin de\u011ferini; $ git config --get core.filemode true --get GRUP.DE\u011e\u0130\u015eKEN \u015feklinde okuruz. Asl\u0131nda --get opsiyonel. Yani yazmak zorunda de\u011filsiniz: $ git config user.name U\u011fur \u00d6zy\u0131lmazel Ben homebrew \u2019la beraber bash-completion paketini de kulland\u0131\u011f\u0131m i\u00e7in, pek \u00e7ok GIT i\u015flemini auto-complete ya da tab-completion ya da otomatik olarak TAB tu\u015funa bas\u0131nca tamamlama ile kullan\u0131yorum. \u0130\u015flerim s\u00fcper kolayla\u015f\u0131yor ve daha az \u015fey ezberlemek durumunda kal\u0131yorum. 19 A\u011fustos 2021 Mutlaka tavsiye ederim: $ brew install git-extras Linux t\u00fcrevleri genelde GIT paketini kurunca otomatik olarak bu tamamlamay\u0131 da beraberinde getiriyor.","title":"De\u011fer Okumak: --get"},{"location":"bolum-01/06-konfigurasyon-islemleri/#degeri-silmek-unset","text":"\u015eimdi denemek i\u00e7in kullan\u0131c\u0131 seviyesinde de\u011fer atamas\u0131 yapal\u0131m: $ git config --global alias.s status bu komut ile k\u0131sa yol tan\u0131mlad\u0131k. art\u0131k git status yerine git s yapmak yeterli. Bu alias konusuna ileride daha detayl\u0131 girece\u011fiz. \u015eimdi bu k\u0131sa yolu silmek i\u00e7in: $ git config --global --unset alias.s yapmak yeterli.","title":"De\u011feri Silmek: --unset"},{"location":"bolum-01/06-konfigurasyon-islemleri/#include-ve-includeif","text":"Yan\u0131lm\u0131yorsam GIT versiyon 2.10+ ile gelen, benim \u00e7ok sevdi\u011fim hayat\u0131m\u0131 kolayla\u015ft\u0131ran 2 direktif. Benim gibi evde ki\u015fisel bilgisayar, i\u015fte ofis bilgisayar\u0131 kullan\u0131yorsan\u0131z asl\u0131nda 2 farkl\u0131 insan gibisiniz. Belki birden fazla bilgisayar\u0131n\u0131z var. Duruma g\u00f6re her bilgisayar\u0131n \u00f6zel bir konfig\u00fcrasyon direktifine ihtiyac\u0131 olabilir. Ya da sadece belli dizinlerin alt\u0131nda belli ayarlar \u00e7al\u0131\u015fsa? Her bilgisayarda ortak ~/.gitconfig dosyas\u0131n\u0131 kullanmak ama bilgisayar\u0131na g\u00f6re ayar yapmak istiyordum. \u0130\u015fte bu durumda imdad\u0131ma include yeti\u015fti. [include] path = ~/.gitlocalconfig ~/.gitlocalconfig bu dosya her iki bilgisayar\u0131mda da bulunuyor. Ana GIT konfig\u00fcrasyon dosyamda user grubunda name ve email ayarlar\u0131 var. Farkl\u0131 bilgisayarlarda farkl\u0131 GPG anahtarlar\u0131 kulland\u0131\u011f\u0131m i\u00e7in ( bunun ne oldu\u011funu ileride anlataca\u011f\u0131m ) user.signingkey de\u011feri her makine i\u00e7in farkl\u0131 :) E\u011fer bulundu\u011fum dizin ~/Dev/Amiga/Bronx-Sources/ ise ~/.gitconfig-bronx-repos konfig\u00fcrasyon dosyas\u0131n\u0131 kullan demek istiyorum. Nas\u0131l m\u0131? [includeIf \"gitdir:~/Dev/Amiga/Bronx-Sources/\"] path = ~/.gitconfig-bronx-repos Bu dosyada yani ~/.gitconfig-bronx-repos dosyas\u0131nda ne mi var? [user] name = vigo/bronx email = vigo@bronx....org signingkey = D3M(O)(SC/\\/3) yani ben ne zaman cd ~/Dev/Amiga/Bronx-Sources/ yap\u0131p, bu dizin alt\u0131nda bulunan herhangi bir repoda i\u015flem yapacak olursam, yukar\u0131daki de\u011ferler aktif olacak! Bana \u015fu soruyu sorabilirsiniz: Neden Local olarak ayar yapmad\u0131n? \u0130lgili dizin alt\u0131n 300 tane repo olsa? tek-tek dizinlerin alt\u0131na gidip git config yapmak zorunda kalmak iyi bir fikir mi? Son olarak path = dosya mant\u0131\u011f\u0131nda birden fazla path tan\u0131mlamak m\u00fcmk\u00fcn: [include] path = ~/.git-localconfig-1 path = ~/.git-localconfig-2 path = ~/.git-localconfig-3 [includeIf \"gitdir:~/Dev/C64/Zombie-Boys-Sources/\"] path = ~/.git-zb-config-1 path = ~/.git-zb-config-2 gibi...","title":"include ve includeIf"},{"location":"bolum-01/07-konfigurasyon-dosyasi/","text":"Konfig\u00fcrasyon Dosyas\u0131 Windows i\u015fletim sistemi d\u00fcnyas\u0131ndaki .ini format\u0131n\u0131 and\u0131ran bir deklarasyon sistemi bulunur. Dosya i\u00e7inde whitespaces yani bo\u015fluk / alfabe d\u0131\u015f\u0131ndaki karakterler g\u00f6rmezden gelinir. Kabaca; [b\u00f6l\u00fcm] de\u011fi\u015fken = de\u011fer de\u011fi\u015fken = de\u011fer : : stilindedir. .git/config Bu dosya Local yani bulundu\u011fumuz repo alt\u0131ndaki .git/ alt\u0131nda bulunur ve sadece o repo ile ilgili ayarlar\u0131 tutar. Bu kapsamda ayar yapmak i\u00e7in; $ git config user.name \"Bu repo i\u00e7in kullanaca\u011f\u0131n\u0131z AD SOYAD bilginiz\" $ git config user.email \"Bu repo i\u00e7in kullanaca\u011f\u0131n\u0131z E-POSTA bilginiz\" # ya da: $ git config --local user.name \"Bu repo i\u00e7in kullanaca\u011f\u0131n\u0131z AD SOYAD bilginiz\" $ git config --local user.email \"Bu repo i\u00e7in kullanaca\u011f\u0131n\u0131z E-POSTA bilginiz\" # \u00f6rnek: # git config user.name \"U\u011fur \u00d6zy\u0131lmazel\" # git config user.email \"vigo@example-local.com\" \u015feklinde i\u015flem yap\u0131l\u0131r. --local anahtar kelimesi opsiyoneldir. Kullanmazsan\u0131z s\u0131k\u0131nt\u0131 olmaz. ~/.gitconfig Global dedi\u011fimiz, i\u015fletim sistemine login olmu\u015f kullan\u0131c\u0131 ile ilgili ayarlar\u0131n tutuldu\u011fu dosyad\u0131r. Bu kapsamda ayar yapmak i\u00e7in; $ git config --global user.name \"AD SOYAD\" $ git config --global user.email \"E-POSTA\" # git config --global user.name \"U\u011fur \u00d6zy\u0131lmazel\" # git config --global user.name \"ugurozyilmazel@...com\" \u015feklinde i\u015flem yap\u0131l\u0131r. \u0130\u015fin s\u0131rr\u0131 --global anahtar kelimesindedir. /etc/gitconfig Bu da t\u00fcm i\u015fletim sistemini etkileyen system-wide ayarlar\u0131n sakland\u0131\u011f\u0131 dosyad\u0131r. Bu kapsamda ayar yapmak i\u00e7in; sudo yetkisi gerekir ve; $ git config --system alias.st status $ git config --system color.ui true gibi i\u015flem yap\u0131l\u0131r ve t\u00fcm kullan\u0131c\u0131lar\u0131n ortak kullanabilecekleri \u015feyleri ayarlamak mant\u0131kl\u0131d\u0131r. E\u011fer benim gibi macOS kullan\u0131yorsan\u0131z ve GIT\u2019i Homebrew \u2019dan kurduysan\u0131z, bu dosyan\u0131n bulundu\u011fu yer: /usr/local/etc/gitconfig \u2019dir.","title":"Konfig\u00fcrasyon Dosyas\u0131"},{"location":"bolum-01/07-konfigurasyon-dosyasi/#konfigurasyon-dosyas","text":"Windows i\u015fletim sistemi d\u00fcnyas\u0131ndaki .ini format\u0131n\u0131 and\u0131ran bir deklarasyon sistemi bulunur. Dosya i\u00e7inde whitespaces yani bo\u015fluk / alfabe d\u0131\u015f\u0131ndaki karakterler g\u00f6rmezden gelinir. Kabaca; [b\u00f6l\u00fcm] de\u011fi\u015fken = de\u011fer de\u011fi\u015fken = de\u011fer : : stilindedir.","title":"Konfig\u00fcrasyon Dosyas\u0131"},{"location":"bolum-01/07-konfigurasyon-dosyasi/#gitconfig","text":"Bu dosya Local yani bulundu\u011fumuz repo alt\u0131ndaki .git/ alt\u0131nda bulunur ve sadece o repo ile ilgili ayarlar\u0131 tutar. Bu kapsamda ayar yapmak i\u00e7in; $ git config user.name \"Bu repo i\u00e7in kullanaca\u011f\u0131n\u0131z AD SOYAD bilginiz\" $ git config user.email \"Bu repo i\u00e7in kullanaca\u011f\u0131n\u0131z E-POSTA bilginiz\" # ya da: $ git config --local user.name \"Bu repo i\u00e7in kullanaca\u011f\u0131n\u0131z AD SOYAD bilginiz\" $ git config --local user.email \"Bu repo i\u00e7in kullanaca\u011f\u0131n\u0131z E-POSTA bilginiz\" # \u00f6rnek: # git config user.name \"U\u011fur \u00d6zy\u0131lmazel\" # git config user.email \"vigo@example-local.com\" \u015feklinde i\u015flem yap\u0131l\u0131r. --local anahtar kelimesi opsiyoneldir. Kullanmazsan\u0131z s\u0131k\u0131nt\u0131 olmaz.","title":".git/config"},{"location":"bolum-01/07-konfigurasyon-dosyasi/#gitconfig_1","text":"Global dedi\u011fimiz, i\u015fletim sistemine login olmu\u015f kullan\u0131c\u0131 ile ilgili ayarlar\u0131n tutuldu\u011fu dosyad\u0131r. Bu kapsamda ayar yapmak i\u00e7in; $ git config --global user.name \"AD SOYAD\" $ git config --global user.email \"E-POSTA\" # git config --global user.name \"U\u011fur \u00d6zy\u0131lmazel\" # git config --global user.name \"ugurozyilmazel@...com\" \u015feklinde i\u015flem yap\u0131l\u0131r. \u0130\u015fin s\u0131rr\u0131 --global anahtar kelimesindedir.","title":"~/.gitconfig"},{"location":"bolum-01/07-konfigurasyon-dosyasi/#etcgitconfig","text":"Bu da t\u00fcm i\u015fletim sistemini etkileyen system-wide ayarlar\u0131n sakland\u0131\u011f\u0131 dosyad\u0131r. Bu kapsamda ayar yapmak i\u00e7in; sudo yetkisi gerekir ve; $ git config --system alias.st status $ git config --system color.ui true gibi i\u015flem yap\u0131l\u0131r ve t\u00fcm kullan\u0131c\u0131lar\u0131n ortak kullanabilecekleri \u015feyleri ayarlamak mant\u0131kl\u0131d\u0131r. E\u011fer benim gibi macOS kullan\u0131yorsan\u0131z ve GIT\u2019i Homebrew \u2019dan kurduysan\u0131z, bu dosyan\u0131n bulundu\u011fu yer: /usr/local/etc/gitconfig \u2019dir.","title":"/etc/gitconfig"},{"location":"bolum-01/08-temel-konfigurasyon-ogeleri/","text":"Temel Konfig\u00fcrasyon \u00d6\u011feleri core.editor git commit , git merge gibi durumlarda mesaj yazaca\u011f\u0131n\u0131z edit\u00f6r\u00fc ayarlamak i\u00e7in kullan\u0131l\u0131r. Default olarak GIT, environment\u2019\u0131n\u0131zdaki $VISUAL ya da $EDITOR de\u011fi\u015fkenlerine bakar. \u00d6rne\u011fin, editor olarak emacs kullanacaksan\u0131z ve; $ export EDITOR = \"emacs\" \u015feklinde bir atama yapt\u0131ysan\u0131z edit\u00f6r\u00fcn\u00fcz emacs olmu\u015f demektir. Environment bazl\u0131 $EDITOR de\u011fi\u015fkeni \u00f6rnekleri: export $EDITOR = \"mate -w\" # TextMate <3 export $EDITOR = \"emacs\" # Emacs export $EDITOR = \"vim\" # Vim export $EDITOR = \"atom --wait\" # Atom export $EDITOR = \"subl -n -w\" # Sublime Text E\u011fer environment\u2019dan ayar yapmad\u0131ysan\u0131z, GIT \u00fczerinden de bu ayarlamay\u0131 yapabilirsiniz. A\u015fa\u011f\u0131da \u00e7e\u015fitli edit\u00f6r ayar \u00f6rnekleri var. Hangi edit\u00f6r\u00fc kullanacaksan\u0131z ilgili sat\u0131r\u0131 uygulayabilirsiniz. $ git config --global core.editor emacs # emacs $ git config --global core.editor vim # vim $ git config --global core.editor \"mate -w\" # TextMate $ git config --global core.editor \"atom --wait\" # Atom $ git config --global core.editor \"subl -n -w\" # Sublime color Renk ile ilgili i\u015fler i\u00e7in kullan\u0131r\u0131z. git status , git diff gibi durumlarda renkli g\u00f6rmek alg\u0131lamam\u0131z\u0131 kolayla\u015ft\u0131r\u0131r. Bunu aktive etmek i\u00e7in: $ git config --global color.ui true yapmam\u0131z gerekir. Renklerini d\u00fczenleyebilece\u011fimiz alt ba\u015fl\u0131klardan baz\u0131lar\u0131: branch , diff , status a\u015fa\u011f\u0131daki gibi ayarlanabilir. $ git config --global color.status auto $ git config --global color.diff auto $ git config --global color.branch auto Bu, GIT\u2019in sizin ortam\u0131n\u0131za g\u00f6re, kulland\u0131\u011f\u0131n\u0131z Terminal\u2019e g\u00f6re renk ayarlamas\u0131 yapmas\u0131 anlam\u0131ndad\u0131r. \u0130ste\u011fe g\u00f6re renk de\u011ferleri vermek m\u00fcmk\u00fcn. Hemen ~/.gitconfig dosyan\u0131z\u0131 a\u00e7\u0131p: [color \"branch\"] current = yellow reverse local = yellow remote = green [color \"diff\"] meta = yellow bold frag = magenta bold old = red bold new = green bold [color \"status\"] added = yellow bold changed = green untracked = red gibi ayar \u00e7ekebilirsiniz. Yapt\u0131\u011f\u0131m\u0131z ayar\u0131 kontrol etmek i\u00e7in; $ git config color.status.added yellow bold geldiyse ayar do\u011fru yap\u0131lm\u0131\u015f demektir. commit.template \u0130lerleyen b\u00f6l\u00fcmlerde; Commit nedir? Commit Mesaj\u0131 nedir? konusunda \u00e7ok i\u015fimize yarayacak bir ayar \u00f6zelli\u011fidir. Commit mesaj\u0131 yazarken bize haz\u0131r \u015fablon \u00e7\u0131kmas\u0131n\u0131 sa\u011flar\u0131z bu \u00f6zellikle. \u015eablon i\u00e7in bir dosya olu\u015fturmak gerekiyor ve daha sonra kendi konfig\u00fcrasyon dosyan\u0131zda bu dosyan\u0131n yerini bildirmeniz gerekiyor. Ben bu dosyay\u0131 $HOME/.git-commit-template.txt \u015feklinde kullan\u0131yorum. $ git config --global commit.template ~/.git-commit-template.txt # \u00f6rnek \u015feklinde konfig\u00fcrasyonu ayarlaman\u0131z gerekir. Peki bu \u015fablon dosyas\u0131nda ne yaz\u0131yor? [\u0130lk 50 karakter: \u00d6zet] [A\u00e7\u0131klama: Neler oldu?] [Fixed #] gibi bir \u015fema kullanabilirsiniz. Bu durumda her git commit dedi\u011finizde bu \u015fablon kar\u015f\u0131n\u0131za \u00e7\u0131kacak ve gerekli yerleri doldurman\u0131z/silmeniz yeterli olacakt\u0131r. help.autocorrect Yanl\u0131\u015f yazd\u0131\u011f\u0131n\u0131zda, size yard\u0131mc\u0131 olacak bir asistan! \u00d6rne\u011fin git commit yerine git conmit yazd\u0131\u011f\u0131n\u0131zda bunun commit oldu\u011funu anlayacak ve bu \u015fekilde hareket edecek. $ git config --global help.autocorrect true Not: GIT prati\u011fi a\u00e7\u0131s\u0131ndan bunu aktif etmeyi \u00f6nermiyorum. El al\u0131\u015fkanl\u0131\u011f\u0131 i\u00e7in do\u011fru yazmay\u0131 \u00f6\u011frenmek her zaman daha do\u011fru diye d\u00fc\u015f\u00fcn\u00fcyorum. core.autocrlf \u0130\u015fletim sistemlerine g\u00f6re LINE ENDINGS yani sat\u0131r sonu/bitimi farkl\u0131l\u0131klar g\u00f6steriyor. \u00d6zellikle Windows! Bir projede hem Windows hem Unix kullan\u0131c\u0131s\u0131 dosya kaydetti\u011finde, aralar\u0131nda s\u0131k\u0131nt\u0131 ya\u015famamak i\u00e7in ufak bir ayar yapmalar\u0131 gerekiyor. Windows kullan\u0131c\u0131s\u0131: $ git config --global core.autocrlf true Unix ( Mac/Linux vb... ) $ git config --global core.autocrlf input yapmas\u0131 her iki kullan\u0131c\u0131 i\u00e7in de s\u0131k\u0131nt\u0131y\u0131 ortadan kald\u0131r\u0131yor. Windows sat\u0131r sonlar\u0131na \\r\\n eklerken Unix t\u00fcrevleri \\n ekliyor. \\n Line feed anlam\u0131ndad\u0131r ve sonraki sat\u0131r\u0131 ifade eder. C arriage R eturn L ine F eed ise ek olarak cursor\u2019u ( imle\u00e7i ) da ba\u015fa al\u0131r. Bu bak\u0131mdan \\n yerine \\r\\n kullan\u0131r. Konfig\u00fcrasyondaki bu ayarlama \u00f6zelli\u011fi sayesinde Windows kullan\u0131c\u0131s\u0131n\u0131n d\u00fczenlendi\u011fi dosyay\u0131 Linux/Unix kullan\u0131c\u0131s\u0131 a\u00e7t\u0131\u011f\u0131nda sorun ya\u015famad\u0131\u011f\u0131 gibi Windows kullan\u0131c\u0131s\u0131 da Linux/Unix kullan\u0131c\u0131s\u0131ndan gelen dosyalar\u0131 s\u0131k\u0131nt\u0131s\u0131z a\u00e7abiliyor. core.whitespace GIT default olarak bo\u015fluk karakteriyle ilgili bir k\u0131s\u0131m anlama \u00f6zelli\u011fi ile geliyor. Default olarak gelen 3 se\u00e7enek ; blank-at-eol : Sat\u0131r sonundaki space ( bo\u015fluk ) karakter(ler)i blank-at-eof : Dosya sonundaki space ( bo\u015fluk ) karakter(ler)i space-before-tab : Sat\u0131r ba\u015f\u0131ndaki tab karakterinden \u00f6nce gelen space ( bo\u015fluk ) karakter(ler)i Buna ek olarak kapal\u0131 ( disabled ) gelen 3 \u00f6zellik ; indent-with-non-tab : tab yerine space ile indent (girintilenmi\u015f) edilmi\u015fler tab-in-indent : Sat\u0131r i\u00e7indeki tab ile girintilenmi\u015f yerler cr-at-eol : Sat\u0131r sonundaki carriage returns yani ENTER/RETURN tu\u015funa bas\u0131nca \u00e7\u0131kanlar d\u00fczg\u00fcn m\u00fc? Bu konu ile ilgili farkl\u0131 konfig\u00fcrasyon kullan\u0131mlar\u0131 bulunmakta. whitespace sorunu ya\u015famamak i\u00e7in ben; $ git config --global core.whitespace fix,-indent-with-non-tab,trailing-space,cr-at-eol \u015feklinde kullan\u0131yorum. Ba\u015fka bir \u00f6rnekte: $ git config --global core.whitespace trailing-space,space-before-tab core.excludesfile .gitignore dosyas\u0131n\u0131n global olan\u0131. Dizin baz\u0131nda .gitignore ile dosyalar\u0131 revizyon kontrol d\u0131\u015f\u0131nda tutabiliyoruz. Bunu genel olarak kullanmak istersek, ayn\u0131 ~/.gitconfig gibi ~/.global_gitignore gibi bir dosya olu\u015fturup: $ git config --global core.excludesfile ~/.global_gitignore gibi ayarlarsak, otomatik olarak belirledi\u011fimiz dosyalar\u0131 revizyon kontrol d\u0131\u015f\u0131na alabiliriz. Unutmay\u0131n ki, proje bazl\u0131 .gitignore dosyas\u0131, repository i\u00e7inde oldu\u011fu i\u00e7in, projeye katk\u0131 yapan di\u011fer kullan\u0131c\u0131lar taraf\u0131ndan da kullan\u0131labiliyor. Bu bak\u0131mdan, global olarak ignore etti\u011finiz \u015feyler ba\u015fka kimseye ge\u00e7meyece\u011fi i\u00e7in dikkatli kullan\u0131n. \u00d6rnek bir .gitignore : .DS_Store ._ * .Spotlight-V100 .Trashes * .pyc xcuserdata .sass-cache .bundle vendor / bundle Pek \u00e7ok temporary ( temp ) dosya ve benzeri \u015feyleri ignore eden bu dosyaya bir g\u00f6z at\u0131n derim. rerere Re use re corded re solution yani merge esnas\u0131nda ya\u015fanan conflict\u2019lerin \u00e7\u00f6z\u00fcmlerini hat\u0131rla ve bir daha ayn\u0131s\u0131 olursa otomatik olarak \u00e7\u00f6z! GIT bazen bizden daha ak\u0131ll\u0131 olabiliyor :) Bu \u00f6zelli\u011fi aktive etmek i\u00e7in; $ git config --global rerere.enabled true yapmak yeterli. status.submoduleSummary Submodule\u2019ler le \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131z zaman i\u015finize yarayacak. git status dedi\u011finizde, repo alt\u0131ndaki submodule\u2019lerin de durumunu g\u00f6rmeniz gerekebilir. $ git config --global status.submoduleSummary true","title":"Temel Konfig\u00fcrasyon \u00d6\u011feleri"},{"location":"bolum-01/08-temel-konfigurasyon-ogeleri/#temel-konfigurasyon-ogeleri","text":"","title":"Temel Konfig\u00fcrasyon \u00d6\u011feleri"},{"location":"bolum-01/08-temel-konfigurasyon-ogeleri/#coreeditor","text":"git commit , git merge gibi durumlarda mesaj yazaca\u011f\u0131n\u0131z edit\u00f6r\u00fc ayarlamak i\u00e7in kullan\u0131l\u0131r. Default olarak GIT, environment\u2019\u0131n\u0131zdaki $VISUAL ya da $EDITOR de\u011fi\u015fkenlerine bakar. \u00d6rne\u011fin, editor olarak emacs kullanacaksan\u0131z ve; $ export EDITOR = \"emacs\" \u015feklinde bir atama yapt\u0131ysan\u0131z edit\u00f6r\u00fcn\u00fcz emacs olmu\u015f demektir. Environment bazl\u0131 $EDITOR de\u011fi\u015fkeni \u00f6rnekleri: export $EDITOR = \"mate -w\" # TextMate <3 export $EDITOR = \"emacs\" # Emacs export $EDITOR = \"vim\" # Vim export $EDITOR = \"atom --wait\" # Atom export $EDITOR = \"subl -n -w\" # Sublime Text E\u011fer environment\u2019dan ayar yapmad\u0131ysan\u0131z, GIT \u00fczerinden de bu ayarlamay\u0131 yapabilirsiniz. A\u015fa\u011f\u0131da \u00e7e\u015fitli edit\u00f6r ayar \u00f6rnekleri var. Hangi edit\u00f6r\u00fc kullanacaksan\u0131z ilgili sat\u0131r\u0131 uygulayabilirsiniz. $ git config --global core.editor emacs # emacs $ git config --global core.editor vim # vim $ git config --global core.editor \"mate -w\" # TextMate $ git config --global core.editor \"atom --wait\" # Atom $ git config --global core.editor \"subl -n -w\" # Sublime","title":"core.editor"},{"location":"bolum-01/08-temel-konfigurasyon-ogeleri/#color","text":"Renk ile ilgili i\u015fler i\u00e7in kullan\u0131r\u0131z. git status , git diff gibi durumlarda renkli g\u00f6rmek alg\u0131lamam\u0131z\u0131 kolayla\u015ft\u0131r\u0131r. Bunu aktive etmek i\u00e7in: $ git config --global color.ui true yapmam\u0131z gerekir. Renklerini d\u00fczenleyebilece\u011fimiz alt ba\u015fl\u0131klardan baz\u0131lar\u0131: branch , diff , status a\u015fa\u011f\u0131daki gibi ayarlanabilir. $ git config --global color.status auto $ git config --global color.diff auto $ git config --global color.branch auto Bu, GIT\u2019in sizin ortam\u0131n\u0131za g\u00f6re, kulland\u0131\u011f\u0131n\u0131z Terminal\u2019e g\u00f6re renk ayarlamas\u0131 yapmas\u0131 anlam\u0131ndad\u0131r. \u0130ste\u011fe g\u00f6re renk de\u011ferleri vermek m\u00fcmk\u00fcn. Hemen ~/.gitconfig dosyan\u0131z\u0131 a\u00e7\u0131p: [color \"branch\"] current = yellow reverse local = yellow remote = green [color \"diff\"] meta = yellow bold frag = magenta bold old = red bold new = green bold [color \"status\"] added = yellow bold changed = green untracked = red gibi ayar \u00e7ekebilirsiniz. Yapt\u0131\u011f\u0131m\u0131z ayar\u0131 kontrol etmek i\u00e7in; $ git config color.status.added yellow bold geldiyse ayar do\u011fru yap\u0131lm\u0131\u015f demektir.","title":"color"},{"location":"bolum-01/08-temel-konfigurasyon-ogeleri/#committemplate","text":"\u0130lerleyen b\u00f6l\u00fcmlerde; Commit nedir? Commit Mesaj\u0131 nedir? konusunda \u00e7ok i\u015fimize yarayacak bir ayar \u00f6zelli\u011fidir. Commit mesaj\u0131 yazarken bize haz\u0131r \u015fablon \u00e7\u0131kmas\u0131n\u0131 sa\u011flar\u0131z bu \u00f6zellikle. \u015eablon i\u00e7in bir dosya olu\u015fturmak gerekiyor ve daha sonra kendi konfig\u00fcrasyon dosyan\u0131zda bu dosyan\u0131n yerini bildirmeniz gerekiyor. Ben bu dosyay\u0131 $HOME/.git-commit-template.txt \u015feklinde kullan\u0131yorum. $ git config --global commit.template ~/.git-commit-template.txt # \u00f6rnek \u015feklinde konfig\u00fcrasyonu ayarlaman\u0131z gerekir. Peki bu \u015fablon dosyas\u0131nda ne yaz\u0131yor? [\u0130lk 50 karakter: \u00d6zet] [A\u00e7\u0131klama: Neler oldu?] [Fixed #] gibi bir \u015fema kullanabilirsiniz. Bu durumda her git commit dedi\u011finizde bu \u015fablon kar\u015f\u0131n\u0131za \u00e7\u0131kacak ve gerekli yerleri doldurman\u0131z/silmeniz yeterli olacakt\u0131r.","title":"commit.template"},{"location":"bolum-01/08-temel-konfigurasyon-ogeleri/#helpautocorrect","text":"Yanl\u0131\u015f yazd\u0131\u011f\u0131n\u0131zda, size yard\u0131mc\u0131 olacak bir asistan! \u00d6rne\u011fin git commit yerine git conmit yazd\u0131\u011f\u0131n\u0131zda bunun commit oldu\u011funu anlayacak ve bu \u015fekilde hareket edecek. $ git config --global help.autocorrect true Not: GIT prati\u011fi a\u00e7\u0131s\u0131ndan bunu aktif etmeyi \u00f6nermiyorum. El al\u0131\u015fkanl\u0131\u011f\u0131 i\u00e7in do\u011fru yazmay\u0131 \u00f6\u011frenmek her zaman daha do\u011fru diye d\u00fc\u015f\u00fcn\u00fcyorum.","title":"help.autocorrect"},{"location":"bolum-01/08-temel-konfigurasyon-ogeleri/#coreautocrlf","text":"\u0130\u015fletim sistemlerine g\u00f6re LINE ENDINGS yani sat\u0131r sonu/bitimi farkl\u0131l\u0131klar g\u00f6steriyor. \u00d6zellikle Windows! Bir projede hem Windows hem Unix kullan\u0131c\u0131s\u0131 dosya kaydetti\u011finde, aralar\u0131nda s\u0131k\u0131nt\u0131 ya\u015famamak i\u00e7in ufak bir ayar yapmalar\u0131 gerekiyor. Windows kullan\u0131c\u0131s\u0131: $ git config --global core.autocrlf true Unix ( Mac/Linux vb... ) $ git config --global core.autocrlf input yapmas\u0131 her iki kullan\u0131c\u0131 i\u00e7in de s\u0131k\u0131nt\u0131y\u0131 ortadan kald\u0131r\u0131yor. Windows sat\u0131r sonlar\u0131na \\r\\n eklerken Unix t\u00fcrevleri \\n ekliyor. \\n Line feed anlam\u0131ndad\u0131r ve sonraki sat\u0131r\u0131 ifade eder. C arriage R eturn L ine F eed ise ek olarak cursor\u2019u ( imle\u00e7i ) da ba\u015fa al\u0131r. Bu bak\u0131mdan \\n yerine \\r\\n kullan\u0131r. Konfig\u00fcrasyondaki bu ayarlama \u00f6zelli\u011fi sayesinde Windows kullan\u0131c\u0131s\u0131n\u0131n d\u00fczenlendi\u011fi dosyay\u0131 Linux/Unix kullan\u0131c\u0131s\u0131 a\u00e7t\u0131\u011f\u0131nda sorun ya\u015famad\u0131\u011f\u0131 gibi Windows kullan\u0131c\u0131s\u0131 da Linux/Unix kullan\u0131c\u0131s\u0131ndan gelen dosyalar\u0131 s\u0131k\u0131nt\u0131s\u0131z a\u00e7abiliyor.","title":"core.autocrlf"},{"location":"bolum-01/08-temel-konfigurasyon-ogeleri/#corewhitespace","text":"GIT default olarak bo\u015fluk karakteriyle ilgili bir k\u0131s\u0131m anlama \u00f6zelli\u011fi ile geliyor. Default olarak gelen 3 se\u00e7enek ; blank-at-eol : Sat\u0131r sonundaki space ( bo\u015fluk ) karakter(ler)i blank-at-eof : Dosya sonundaki space ( bo\u015fluk ) karakter(ler)i space-before-tab : Sat\u0131r ba\u015f\u0131ndaki tab karakterinden \u00f6nce gelen space ( bo\u015fluk ) karakter(ler)i Buna ek olarak kapal\u0131 ( disabled ) gelen 3 \u00f6zellik ; indent-with-non-tab : tab yerine space ile indent (girintilenmi\u015f) edilmi\u015fler tab-in-indent : Sat\u0131r i\u00e7indeki tab ile girintilenmi\u015f yerler cr-at-eol : Sat\u0131r sonundaki carriage returns yani ENTER/RETURN tu\u015funa bas\u0131nca \u00e7\u0131kanlar d\u00fczg\u00fcn m\u00fc? Bu konu ile ilgili farkl\u0131 konfig\u00fcrasyon kullan\u0131mlar\u0131 bulunmakta. whitespace sorunu ya\u015famamak i\u00e7in ben; $ git config --global core.whitespace fix,-indent-with-non-tab,trailing-space,cr-at-eol \u015feklinde kullan\u0131yorum. Ba\u015fka bir \u00f6rnekte: $ git config --global core.whitespace trailing-space,space-before-tab","title":"core.whitespace"},{"location":"bolum-01/08-temel-konfigurasyon-ogeleri/#coreexcludesfile","text":".gitignore dosyas\u0131n\u0131n global olan\u0131. Dizin baz\u0131nda .gitignore ile dosyalar\u0131 revizyon kontrol d\u0131\u015f\u0131nda tutabiliyoruz. Bunu genel olarak kullanmak istersek, ayn\u0131 ~/.gitconfig gibi ~/.global_gitignore gibi bir dosya olu\u015fturup: $ git config --global core.excludesfile ~/.global_gitignore gibi ayarlarsak, otomatik olarak belirledi\u011fimiz dosyalar\u0131 revizyon kontrol d\u0131\u015f\u0131na alabiliriz. Unutmay\u0131n ki, proje bazl\u0131 .gitignore dosyas\u0131, repository i\u00e7inde oldu\u011fu i\u00e7in, projeye katk\u0131 yapan di\u011fer kullan\u0131c\u0131lar taraf\u0131ndan da kullan\u0131labiliyor. Bu bak\u0131mdan, global olarak ignore etti\u011finiz \u015feyler ba\u015fka kimseye ge\u00e7meyece\u011fi i\u00e7in dikkatli kullan\u0131n. \u00d6rnek bir .gitignore : .DS_Store ._ * .Spotlight-V100 .Trashes * .pyc xcuserdata .sass-cache .bundle vendor / bundle Pek \u00e7ok temporary ( temp ) dosya ve benzeri \u015feyleri ignore eden bu dosyaya bir g\u00f6z at\u0131n derim.","title":"core.excludesfile"},{"location":"bolum-01/08-temel-konfigurasyon-ogeleri/#rerere","text":"Re use re corded re solution yani merge esnas\u0131nda ya\u015fanan conflict\u2019lerin \u00e7\u00f6z\u00fcmlerini hat\u0131rla ve bir daha ayn\u0131s\u0131 olursa otomatik olarak \u00e7\u00f6z! GIT bazen bizden daha ak\u0131ll\u0131 olabiliyor :) Bu \u00f6zelli\u011fi aktive etmek i\u00e7in; $ git config --global rerere.enabled true yapmak yeterli.","title":"rerere"},{"location":"bolum-01/08-temel-konfigurasyon-ogeleri/#statussubmodulesummary","text":"Submodule\u2019ler le \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131z zaman i\u015finize yarayacak. git status dedi\u011finizde, repo alt\u0131ndaki submodule\u2019lerin de durumunu g\u00f6rmeniz gerekebilir. $ git config --global status.submoduleSummary true","title":"status.submoduleSummary"},{"location":"bolum-01/09-ornek-konfigurasyon-dosyasi/","text":"\u00d6rnek Konfig\u00fcrasyon Dosyas\u0131 Bu \u00f6rne\u011fi kendinize g\u00f6re d\u00fczenleyip ~/.gitconfig olarak kullanabilirsiniz. [user] name = AD SOYAD email = E-POSTA [commit] template = ~/.git-commit-template [alias] add-modified = !\"git status -sb | grep '^ M ' | sed 's/ M //' | xargs git add\" add-untracked = !\"git status -sb | grep '^??' | sed 's/?? //' | sed 's/.*/\\\"&\\\"/' | xargs git add\" branches = for-each-ref --sort=-committerdate --format='%(color:white)[%(refname:short):%(color:yellow)%(objectname:short)%(color:reset)]%(color:reset) \\t %(color:red)%(authorname)%(color:reset) \\t %(color:blue)%(authordate:relative)%(color:reset)' refs/remotes show-ignored = \"ls-files -o -i --exclude-standard\" show-todays-diff = \"diff --shortstat '@{0 day ago}'\" show-untracked = \"ls-files --others --exclude-standard\" add-deleted = \"add -u\" root-commit = \"rev-list --max-parents=0 HEAD\" next-commit = !\"git checkout $(git log --reverse --ancestry-path --pretty=%H HEAD..master | head -1)\" unstage = \"reset HEAD --\" uncommit = \"reset --soft HEAD^\" wip = !\"git add -A; git ls-files --deleted -z | xargs -0 git rm; git commit -m 'wip'\" initial-commit-tr = \"commit --allow-empty -m'[root] \u0130lk commit'\" initial-commit = \"commit --allow-empty -m'[root] Initial commit'\" br = \"branch -v\" bra = \"branch -avv\" brd = \"branch -d\" brm = \"branch --no-mergedd\" brnm = \"branch --no-merged\" brr = \"branch -rv\" ci = \"commit\" co = \"checkout\" df = \"diff --word-diff\" dfn = \"diff --name-only\" fc = \"commit --allow-empty -m\" lg = \"log --graph --decorate --oneline --all\" lg2 = \"log --graph --decorate --pretty='%C(auto)%h %G?%d %C(white)%s%C(reset) [%aE, %ad]' --date=relative\" lgs = \"log --graph --decorate --oneline\" list-remote-tags = \"ls-remote --tags\" ls = \"ls-files\" pullr = \"pull --rebase\" rmt = \"remote -v\" st = \"status\" stu = \"status --untracked-files\" sti = \"status --ignored\" sts = \"status -sb\" track-origin-master = \"branch --set-upstream-to=origin/master master\" [color] ui = auto [color \"branch\"] current = yellow reverse local = yellow remote = green [color \"diff\"] meta = yellow bold frag = magenta bold old = red bold new = green bold [color \"status\"] added = yellow bold changed = green untracked = red [core] excludesfile = ~/.gitignore whitespace = fix,-indent-with-non-tab,trailing-space,cr-at-eol pager = less -FRX autocrlf = input safecrlf = true disambiguate = commit abbrev = 12 [push] default = tracking [filter \"media\"] clean = git-media-clean %f smudge = git-media-smudge %f # [pull] # rebase = true # bu se\u00e7ene\u011fi belli bir seviyeye geldikten sonra, # pull --rebase i tam olarak \u00f6z\u00fcmsedikten sonra kullanman\u0131z\u0131 # tavsiye ederim. [fetch] prune = true [rerere] enabled = true [help] autocorrect = 0 [diff] compactionHeuristic = 1 [status] submoduleSummary = true [init] defaultBranch = main","title":"\u00d6rnek Konfig\u00fcrasyon Dosyas\u0131"},{"location":"bolum-01/09-ornek-konfigurasyon-dosyasi/#ornek-konfigurasyon-dosyas","text":"Bu \u00f6rne\u011fi kendinize g\u00f6re d\u00fczenleyip ~/.gitconfig olarak kullanabilirsiniz. [user] name = AD SOYAD email = E-POSTA [commit] template = ~/.git-commit-template [alias] add-modified = !\"git status -sb | grep '^ M ' | sed 's/ M //' | xargs git add\" add-untracked = !\"git status -sb | grep '^??' | sed 's/?? //' | sed 's/.*/\\\"&\\\"/' | xargs git add\" branches = for-each-ref --sort=-committerdate --format='%(color:white)[%(refname:short):%(color:yellow)%(objectname:short)%(color:reset)]%(color:reset) \\t %(color:red)%(authorname)%(color:reset) \\t %(color:blue)%(authordate:relative)%(color:reset)' refs/remotes show-ignored = \"ls-files -o -i --exclude-standard\" show-todays-diff = \"diff --shortstat '@{0 day ago}'\" show-untracked = \"ls-files --others --exclude-standard\" add-deleted = \"add -u\" root-commit = \"rev-list --max-parents=0 HEAD\" next-commit = !\"git checkout $(git log --reverse --ancestry-path --pretty=%H HEAD..master | head -1)\" unstage = \"reset HEAD --\" uncommit = \"reset --soft HEAD^\" wip = !\"git add -A; git ls-files --deleted -z | xargs -0 git rm; git commit -m 'wip'\" initial-commit-tr = \"commit --allow-empty -m'[root] \u0130lk commit'\" initial-commit = \"commit --allow-empty -m'[root] Initial commit'\" br = \"branch -v\" bra = \"branch -avv\" brd = \"branch -d\" brm = \"branch --no-mergedd\" brnm = \"branch --no-merged\" brr = \"branch -rv\" ci = \"commit\" co = \"checkout\" df = \"diff --word-diff\" dfn = \"diff --name-only\" fc = \"commit --allow-empty -m\" lg = \"log --graph --decorate --oneline --all\" lg2 = \"log --graph --decorate --pretty='%C(auto)%h %G?%d %C(white)%s%C(reset) [%aE, %ad]' --date=relative\" lgs = \"log --graph --decorate --oneline\" list-remote-tags = \"ls-remote --tags\" ls = \"ls-files\" pullr = \"pull --rebase\" rmt = \"remote -v\" st = \"status\" stu = \"status --untracked-files\" sti = \"status --ignored\" sts = \"status -sb\" track-origin-master = \"branch --set-upstream-to=origin/master master\" [color] ui = auto [color \"branch\"] current = yellow reverse local = yellow remote = green [color \"diff\"] meta = yellow bold frag = magenta bold old = red bold new = green bold [color \"status\"] added = yellow bold changed = green untracked = red [core] excludesfile = ~/.gitignore whitespace = fix,-indent-with-non-tab,trailing-space,cr-at-eol pager = less -FRX autocrlf = input safecrlf = true disambiguate = commit abbrev = 12 [push] default = tracking [filter \"media\"] clean = git-media-clean %f smudge = git-media-smudge %f # [pull] # rebase = true # bu se\u00e7ene\u011fi belli bir seviyeye geldikten sonra, # pull --rebase i tam olarak \u00f6z\u00fcmsedikten sonra kullanman\u0131z\u0131 # tavsiye ederim. [fetch] prune = true [rerere] enabled = true [help] autocorrect = 0 [diff] compactionHeuristic = 1 [status] submoduleSummary = true [init] defaultBranch = main","title":"\u00d6rnek Konfig\u00fcrasyon Dosyas\u0131"},{"location":"bolum-01/10-kisa-yollar-alias/","text":"K\u0131sa Yollar: alias G\u00fcnl\u00fck hayatta s\u0131k kulland\u0131\u011f\u0131m\u0131z komutlar i\u00e7in k\u0131sa yollar olu\u015fturabiliriz. Buna alias deniyor. \u00d6rne\u011fin; $ git status \u00e7ok kullanaca\u011f\u0131m\u0131z bir i\u015flem olacak. Bu bak\u0131mdan her seferinde git status yazmak yerine git st ya da git s gibi alias tan\u0131tmak m\u00fcmk\u00fcn. Ayn\u0131 di\u011fer konfig\u00fcrasyon elementleri gibi: $ git config --global alias.st status ya da ~/.gitconfig dosyan\u0131z\u0131 a\u00e7\u0131p: [alias] st = status gibi d\u00fczenleme yapabilirsiniz. E\u011fer alias\u2019\u0131n ba\u015f\u0131nda ! i\u015fareti olursa bu shell komut u \u00e7al\u0131\u015ft\u0131rabilece\u011fimiz anlam\u0131na gelir. \u00d6rne\u011fin takip alt\u0131nda olmayan dosyalar\u0131 otomatik olarak takibe almak i\u00e7in komut sat\u0131r\u0131ndan \u015fu i\u015flemler serisini yapabiliriz: $ git status -s # iki tane yeni takip alt\u0131nda olmayan dosya oldu\u011funu d\u00fc\u015f\u00fcn\u00fcnelim, \u00e7\u0131kt\u0131s\u0131 # a\u015fa\u011f\u0131daki gibi olsa; M index.html ?? test.jpg ?? global.js M modified anlam\u0131nda yani daha \u00f6nce kontrol alt\u0131na al\u0131nm\u0131\u015f, ?? ise un-tracked anlam\u0131nda, yani yeni dosya, hi\u00e7bir revizyon bilgisi yok. \u015eimdi; $ git status -s | grep -e \"^??\" ?? test.jpg ?? global.js $ git status -s | grep -e \"^??\" | awk '{ print $2 }' test.jpg global.js ve mini Bash Script Crash Course finalinde; $ git status -s | grep -e \"^??\" | awk '{ print $2 }' | xargs git add yaparak sadece un-tracked olanlar\u0131 ekledik. G\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi yakla\u015f\u0131k 4 komutu zincirleme \u00e7a\u011f\u0131rd\u0131k. Bunu kolay yoldan yapmak i\u00e7in alias olarak ekleyebiliriz: $ git config --global alias.add-untracked '!git status -sb | grep -e \"^??\" | awk \"{ print \\$2 }\" | xargs git add' Bu i\u015flemden sonra git add-untracked dedi\u011fimizde, yeni olu\u015fan, revizyon kontrol alt\u0131nda olmayan dosyalar otomatik olarak eklenecektir. Di\u011fer \u00f6rnek k\u0131sa yollar i\u00e7in \u00d6rnek Konfig\u00fcrasyon Dosyas\u0131 incelenebilir.","title":"K\u0131sa Yollar: `git alias`"},{"location":"bolum-01/10-kisa-yollar-alias/#ksa-yollar-alias","text":"G\u00fcnl\u00fck hayatta s\u0131k kulland\u0131\u011f\u0131m\u0131z komutlar i\u00e7in k\u0131sa yollar olu\u015fturabiliriz. Buna alias deniyor. \u00d6rne\u011fin; $ git status \u00e7ok kullanaca\u011f\u0131m\u0131z bir i\u015flem olacak. Bu bak\u0131mdan her seferinde git status yazmak yerine git st ya da git s gibi alias tan\u0131tmak m\u00fcmk\u00fcn. Ayn\u0131 di\u011fer konfig\u00fcrasyon elementleri gibi: $ git config --global alias.st status ya da ~/.gitconfig dosyan\u0131z\u0131 a\u00e7\u0131p: [alias] st = status gibi d\u00fczenleme yapabilirsiniz. E\u011fer alias\u2019\u0131n ba\u015f\u0131nda ! i\u015fareti olursa bu shell komut u \u00e7al\u0131\u015ft\u0131rabilece\u011fimiz anlam\u0131na gelir. \u00d6rne\u011fin takip alt\u0131nda olmayan dosyalar\u0131 otomatik olarak takibe almak i\u00e7in komut sat\u0131r\u0131ndan \u015fu i\u015flemler serisini yapabiliriz: $ git status -s # iki tane yeni takip alt\u0131nda olmayan dosya oldu\u011funu d\u00fc\u015f\u00fcn\u00fcnelim, \u00e7\u0131kt\u0131s\u0131 # a\u015fa\u011f\u0131daki gibi olsa; M index.html ?? test.jpg ?? global.js M modified anlam\u0131nda yani daha \u00f6nce kontrol alt\u0131na al\u0131nm\u0131\u015f, ?? ise un-tracked anlam\u0131nda, yani yeni dosya, hi\u00e7bir revizyon bilgisi yok. \u015eimdi; $ git status -s | grep -e \"^??\" ?? test.jpg ?? global.js $ git status -s | grep -e \"^??\" | awk '{ print $2 }' test.jpg global.js ve mini Bash Script Crash Course finalinde; $ git status -s | grep -e \"^??\" | awk '{ print $2 }' | xargs git add yaparak sadece un-tracked olanlar\u0131 ekledik. G\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi yakla\u015f\u0131k 4 komutu zincirleme \u00e7a\u011f\u0131rd\u0131k. Bunu kolay yoldan yapmak i\u00e7in alias olarak ekleyebiliriz: $ git config --global alias.add-untracked '!git status -sb | grep -e \"^??\" | awk \"{ print \\$2 }\" | xargs git add' Bu i\u015flemden sonra git add-untracked dedi\u011fimizde, yeni olu\u015fan, revizyon kontrol alt\u0131nda olmayan dosyalar otomatik olarak eklenecektir. Di\u011fer \u00f6rnek k\u0131sa yollar i\u00e7in \u00d6rnek Konfig\u00fcrasyon Dosyas\u0131 incelenebilir.","title":"K\u0131sa Yollar: alias"},{"location":"bolum-01/11-commit-nedir/","text":"Commit Nedir? GIT, kendi i\u00e7inde \u00f6zel bir GRAPH yap\u0131s\u0131 kullan\u0131yor. Bunun ad\u0131: Directed Acyclic Graph . Bence biraz korkutucu :) Bu nedir diyen varsa detaylar\u0131 linkten \u00f6\u011frenebilir. Kabaca ortada bir a\u011fa\u00e7 yap\u0131s\u0131 var. A\u011fac\u0131n kollar\u0131 var, dallar\u0131 var. Kendi \u00f6zel yap\u0131s\u0131 i\u00e7inde GIT de\u011fi\u015fiklikleri kendi y\u00f6ntemleriyle saklar. Akla gelebilecek en basit y\u00f6ntem delta-diff yani sadece de\u011fi\u015fen \u015feyleri saklamak yerine GIT komple o an\u0131n foto\u011fraf\u0131n\u0131 \u00e7eker. Bu asl\u0131nda o an\u2019\u0131n snapshot \u2019\u0131d\u0131r ve GIT buna Commit der. Commit yapt\u0131\u011f\u0131n\u0131z zaman GIT, ad\u0131 commit-object olan bir ta\u015f\u0131y\u0131c\u0131 saklar. Bu ta\u015f\u0131y\u0131c\u0131 i\u00e7inde stage edilmi\u015f i\u00e7erik, commit\u2019i yapan ki\u015fi bilgileri, varsa ba\u011fl\u0131 oldu\u011fu bir \u00fcst commit ya da branch \u2019lerin merge edilmesi ( birle\u015ftirilmesi ) sonunda olu\u015fmu\u015f bir commit ise birden fazla branch bilgisi saklar. Bunlar asl\u0131nda birer i\u015faret\u00e7i yani pointer \u2019d\u0131r. Commit, i\u00e7inde hangi tree yap\u0131s\u0131na dahil oldu\u011fu bilgisini de saklar. \u0130lk commit d\u0131\u015f\u0131ndaki t\u00fcm commit\u2019lerin bir parent-commit \u2019i bulunur. S\u0131f\u0131r bir repo i\u00e7inde yap\u0131lan ilk commit asl\u0131nda o repo\u2019nun root-commit \u2019idir. Hi\u00e7bir commit\u2019ten t\u00fcrememi\u015ftir. \u00d6rnek bir log \u00e7\u0131kt\u0131s\u0131na bakal\u0131m: $ git log --graph --decorate --oneline --all * b72ce45cafdc ( HEAD -> master ) fixed grammar at license section * 504714498c31 hooks folder deleted * 49261317ef93 Release: v0.1.0 * c0672c7d5be6 Ready for v0.1.0 * 71ff5c9dfac2 Added installation feature. * 9bf387240b22 Changed message storage file. * 1e7071c6e6fe Ready to release. Need to finish README. * c3fd828979bc added: README file * b1d90b39ba10 [ root ] initial commit Son yap\u0131lan commit: b72ce45cafdc . Bu commit\u2019in parent\u2019\u0131 504714498c31 ve 504714498c31 commit\u2019in parent\u2019\u0131 49261317ef93 . Parent\u2019\u0131 olmayan tek commit: b1d90b39ba10 Genelde \u015fematik olarak g\u00f6sterilirken; master | 49261317 ef93 <- 504714498 c31 <- b72ce45cafdc ( son commit ) zaman \u00e7izelgesi soldan-sa\u011fa akarken commit\u2019lerin ili\u015fkisi tam ters \u015fekildedir. Her zaman kim kimin \u00fcst\u00fc alt\u0131 ( parent/child ) durumu \u00f6nemlidir.","title":"Commit Nedir?"},{"location":"bolum-01/11-commit-nedir/#commit-nedir","text":"GIT, kendi i\u00e7inde \u00f6zel bir GRAPH yap\u0131s\u0131 kullan\u0131yor. Bunun ad\u0131: Directed Acyclic Graph . Bence biraz korkutucu :) Bu nedir diyen varsa detaylar\u0131 linkten \u00f6\u011frenebilir. Kabaca ortada bir a\u011fa\u00e7 yap\u0131s\u0131 var. A\u011fac\u0131n kollar\u0131 var, dallar\u0131 var. Kendi \u00f6zel yap\u0131s\u0131 i\u00e7inde GIT de\u011fi\u015fiklikleri kendi y\u00f6ntemleriyle saklar. Akla gelebilecek en basit y\u00f6ntem delta-diff yani sadece de\u011fi\u015fen \u015feyleri saklamak yerine GIT komple o an\u0131n foto\u011fraf\u0131n\u0131 \u00e7eker. Bu asl\u0131nda o an\u2019\u0131n snapshot \u2019\u0131d\u0131r ve GIT buna Commit der. Commit yapt\u0131\u011f\u0131n\u0131z zaman GIT, ad\u0131 commit-object olan bir ta\u015f\u0131y\u0131c\u0131 saklar. Bu ta\u015f\u0131y\u0131c\u0131 i\u00e7inde stage edilmi\u015f i\u00e7erik, commit\u2019i yapan ki\u015fi bilgileri, varsa ba\u011fl\u0131 oldu\u011fu bir \u00fcst commit ya da branch \u2019lerin merge edilmesi ( birle\u015ftirilmesi ) sonunda olu\u015fmu\u015f bir commit ise birden fazla branch bilgisi saklar. Bunlar asl\u0131nda birer i\u015faret\u00e7i yani pointer \u2019d\u0131r. Commit, i\u00e7inde hangi tree yap\u0131s\u0131na dahil oldu\u011fu bilgisini de saklar. \u0130lk commit d\u0131\u015f\u0131ndaki t\u00fcm commit\u2019lerin bir parent-commit \u2019i bulunur. S\u0131f\u0131r bir repo i\u00e7inde yap\u0131lan ilk commit asl\u0131nda o repo\u2019nun root-commit \u2019idir. Hi\u00e7bir commit\u2019ten t\u00fcrememi\u015ftir. \u00d6rnek bir log \u00e7\u0131kt\u0131s\u0131na bakal\u0131m: $ git log --graph --decorate --oneline --all * b72ce45cafdc ( HEAD -> master ) fixed grammar at license section * 504714498c31 hooks folder deleted * 49261317ef93 Release: v0.1.0 * c0672c7d5be6 Ready for v0.1.0 * 71ff5c9dfac2 Added installation feature. * 9bf387240b22 Changed message storage file. * 1e7071c6e6fe Ready to release. Need to finish README. * c3fd828979bc added: README file * b1d90b39ba10 [ root ] initial commit Son yap\u0131lan commit: b72ce45cafdc . Bu commit\u2019in parent\u2019\u0131 504714498c31 ve 504714498c31 commit\u2019in parent\u2019\u0131 49261317ef93 . Parent\u2019\u0131 olmayan tek commit: b1d90b39ba10 Genelde \u015fematik olarak g\u00f6sterilirken; master | 49261317 ef93 <- 504714498 c31 <- b72ce45cafdc ( son commit ) zaman \u00e7izelgesi soldan-sa\u011fa akarken commit\u2019lerin ili\u015fkisi tam ters \u015fekildedir. Her zaman kim kimin \u00fcst\u00fc alt\u0131 ( parent/child ) durumu \u00f6nemlidir.","title":"Commit Nedir?"},{"location":"bolum-01/12-ilk-commit/","text":"\u0130lk Commit Dedik ya, zaman\u0131n, o an\u0131n foto\u011fraf\u0131n\u0131 \u00e7ekiyoruz... Foto\u011fraf\u0131 \u00e7ekebilmek i\u00e7in repomuzda dosyalar\u0131n olmas\u0131 gerekiyor. Ben, yeni bir projeye ba\u015flad\u0131\u011f\u0131m zaman, ilk yapt\u0131\u011f\u0131m commit\u2019i bo\u015f commit olarak yap\u0131yorum. Reponun ilk commit\u2019i asl\u0131nda root-commit olup hi\u00e7bir parent commit\u2019e sahip de\u011fildi. Madem \u00f6yle, hi\u00e7bir dosya ile de ili\u015fkilendirmek istemiyorum: $ cd /tmp/ $ git init my-awesome-tool && cd $_ $ git commit --allow-empty -m '[root] Initial commit' [ master ( root-commit ) 2a88b16f848c ] [ root ] Initial commit $ git log --oneline * 2a88b16f848c ( HEAD -> master ) [ root ] Initial commit Commit mesajlar\u0131n\u0131 \u0130ngilizce yazaca\u011f\u0131m. Elimizi buna al\u0131\u015ft\u0131rmam\u0131z laz\u0131m. Hep a\u00e7\u0131k-kaynak projelerde \u00e7al\u0131\u015f\u0131rken ya da ekibe T\u00fcrk\u00e7e bilmeyen biri dahil oldu\u011funda ya da size yabanc\u0131 bir ekiple / projeyle \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131zda s\u0131k\u0131nt\u0131 \u00e7ekmemeniz i\u00e7in iyi bir antrenman olur :)","title":"\u0130lk Commit"},{"location":"bolum-01/12-ilk-commit/#ilk-commit","text":"Dedik ya, zaman\u0131n, o an\u0131n foto\u011fraf\u0131n\u0131 \u00e7ekiyoruz... Foto\u011fraf\u0131 \u00e7ekebilmek i\u00e7in repomuzda dosyalar\u0131n olmas\u0131 gerekiyor. Ben, yeni bir projeye ba\u015flad\u0131\u011f\u0131m zaman, ilk yapt\u0131\u011f\u0131m commit\u2019i bo\u015f commit olarak yap\u0131yorum. Reponun ilk commit\u2019i asl\u0131nda root-commit olup hi\u00e7bir parent commit\u2019e sahip de\u011fildi. Madem \u00f6yle, hi\u00e7bir dosya ile de ili\u015fkilendirmek istemiyorum: $ cd /tmp/ $ git init my-awesome-tool && cd $_ $ git commit --allow-empty -m '[root] Initial commit' [ master ( root-commit ) 2a88b16f848c ] [ root ] Initial commit $ git log --oneline * 2a88b16f848c ( HEAD -> master ) [ root ] Initial commit Commit mesajlar\u0131n\u0131 \u0130ngilizce yazaca\u011f\u0131m. Elimizi buna al\u0131\u015ft\u0131rmam\u0131z laz\u0131m. Hep a\u00e7\u0131k-kaynak projelerde \u00e7al\u0131\u015f\u0131rken ya da ekibe T\u00fcrk\u00e7e bilmeyen biri dahil oldu\u011funda ya da size yabanc\u0131 bir ekiple / projeyle \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131zda s\u0131k\u0131nt\u0131 \u00e7ekmemeniz i\u00e7in iyi bir antrenman olur :)","title":"\u0130lk Commit"},{"location":"bolum-01/13-commit-mesaji-nedir/","text":"Commit Mesaj\u0131 Nedir? GIT\u2019in resmi dok\u00fcmantasyon sitesinde commit\u2019in a\u00e7\u0131klamas\u0131n\u0131 yaparken, mesaj ile ilgili k\u0131s\u0131mda; ... with a log message from the user describing the changes. der. Yani kullan\u0131c\u0131n\u0131n yapt\u0131\u011f\u0131 de\u011fi\u015fiklikleri tarif etti\u011fi, anlatt\u0131\u011f\u0131 kay\u0131tt\u0131r bu asl\u0131nda. \u00c7\u00fcnk\u00fc GIT de\u011fi\u015fiklikleri takip eden bir ara\u00e7t\u0131r. Teknik olarak GIT de\u015fikli\u011fin ne oldu\u011funu biliyor ama sonu\u00e7 olarak kodu yazan insan oldu\u011fu i\u00e7in, insan\u0131n anlayaca\u011f\u0131 \u015fekilde a\u00e7\u0131klamak gerekiyor nelerin de\u011fi\u015fti\u011fini. En h\u0131zl\u0131 \u015fekilde commit mesaj\u0131 yazmak i\u00e7in g\u00fcnl\u00fck hayatta; $ git commit -m \"MESAJ\" kullan\u0131r\u0131z. Bu asl\u0131nda k\u0131sa mesaj kullan\u0131m\u0131d\u0131r. \u00d6rne\u011fin git log --oneline kullan\u0131m\u0131nda ald\u0131\u011f\u0131m\u0131z \u00e7\u0131kt\u0131: a58834812b45 ( HEAD -> master , origin / master , origin / HEAD ) Merge pull request # 1295 from ninoseki / master 875f36f 963 dd Change relative URLs to absolute URLS a1b0de7b45a7 Fixed broken links in rack - protection / README . md ec08e37bf8b4 Linkify protection docs ea1a21c0734e Update homepages for sinatra - contrib and rack - protection gibidir. COMMIT_ID ve COMMIT_MESSAGE \u015feklinde g\u00f6r\u00fcr\u00fcz. Bu k\u0131sa mesaj, asl\u0131nda commit mesaj\u0131n\u0131n ilk sat\u0131r\u0131d\u0131r ve bu ilk sat\u0131r 50 karakter dir. ID\u2019si a58834812b45 olan commit\u2019e bakal\u0131m: $ git show a58834812b45 Merge pull request #1295 from ninoseki/master Fixed broken links in rack-protection/README.md \u0130lk sat\u0131rda k\u0131sa a\u00e7\u0131klama, bir sat\u0131r bo\u015fluk ve mesaj\u0131n devam\u0131 bulunur. Ben de dahil olmak \u00fczere, pek \u00e7ok geli\u015ftirici, yapt\u0131\u011f\u0131 de\u011fi\u015fiklikleri uzun uzun yazmak yerine \u0131\u015f\u0131k h\u0131z\u0131yla; $ git commit -m 'up' $ git commit -m 'update' $ git commit -m 'wip' gibi, asl\u0131nda kavgada bile yap\u0131lmayacak hareketleri yapm\u0131\u015f\u0131zd\u0131r. Neden? Kim onca de\u011fi\u015fikli\u011fi oturup yazacak \u015fimdi? \u0130\u015fte en az\u0131ndan bu durumlar\u0131 minimal d\u00fczeye indirmek i\u00e7in tavsiye edilen ilk y\u00f6ntem: git commit ile commit yapmak, git commit -m 'MESAJ' kullanmamak! Bu y\u00f6ntemle kar\u015f\u0131m\u0131za git config core.editor ile belirlenmi\u015f text edit\u00f6r\u00fc \u00e7\u0131kar ve ferah fezah mesaj yazacak bir alanla kar\u015f\u0131 kar\u015f\u0131ya kal\u0131r\u0131z. B\u00f6yle bir durumda otomatikle\u015ftirilmi\u015f \u015fablon mesaj \u00e7ok i\u015fimize yarayabilir.","title":"Commit Mesaj\u0131 Nedir?"},{"location":"bolum-01/13-commit-mesaji-nedir/#commit-mesaj-nedir","text":"GIT\u2019in resmi dok\u00fcmantasyon sitesinde commit\u2019in a\u00e7\u0131klamas\u0131n\u0131 yaparken, mesaj ile ilgili k\u0131s\u0131mda; ... with a log message from the user describing the changes. der. Yani kullan\u0131c\u0131n\u0131n yapt\u0131\u011f\u0131 de\u011fi\u015fiklikleri tarif etti\u011fi, anlatt\u0131\u011f\u0131 kay\u0131tt\u0131r bu asl\u0131nda. \u00c7\u00fcnk\u00fc GIT de\u011fi\u015fiklikleri takip eden bir ara\u00e7t\u0131r. Teknik olarak GIT de\u015fikli\u011fin ne oldu\u011funu biliyor ama sonu\u00e7 olarak kodu yazan insan oldu\u011fu i\u00e7in, insan\u0131n anlayaca\u011f\u0131 \u015fekilde a\u00e7\u0131klamak gerekiyor nelerin de\u011fi\u015fti\u011fini. En h\u0131zl\u0131 \u015fekilde commit mesaj\u0131 yazmak i\u00e7in g\u00fcnl\u00fck hayatta; $ git commit -m \"MESAJ\" kullan\u0131r\u0131z. Bu asl\u0131nda k\u0131sa mesaj kullan\u0131m\u0131d\u0131r. \u00d6rne\u011fin git log --oneline kullan\u0131m\u0131nda ald\u0131\u011f\u0131m\u0131z \u00e7\u0131kt\u0131: a58834812b45 ( HEAD -> master , origin / master , origin / HEAD ) Merge pull request # 1295 from ninoseki / master 875f36f 963 dd Change relative URLs to absolute URLS a1b0de7b45a7 Fixed broken links in rack - protection / README . md ec08e37bf8b4 Linkify protection docs ea1a21c0734e Update homepages for sinatra - contrib and rack - protection gibidir. COMMIT_ID ve COMMIT_MESSAGE \u015feklinde g\u00f6r\u00fcr\u00fcz. Bu k\u0131sa mesaj, asl\u0131nda commit mesaj\u0131n\u0131n ilk sat\u0131r\u0131d\u0131r ve bu ilk sat\u0131r 50 karakter dir. ID\u2019si a58834812b45 olan commit\u2019e bakal\u0131m: $ git show a58834812b45 Merge pull request #1295 from ninoseki/master Fixed broken links in rack-protection/README.md \u0130lk sat\u0131rda k\u0131sa a\u00e7\u0131klama, bir sat\u0131r bo\u015fluk ve mesaj\u0131n devam\u0131 bulunur. Ben de dahil olmak \u00fczere, pek \u00e7ok geli\u015ftirici, yapt\u0131\u011f\u0131 de\u011fi\u015fiklikleri uzun uzun yazmak yerine \u0131\u015f\u0131k h\u0131z\u0131yla; $ git commit -m 'up' $ git commit -m 'update' $ git commit -m 'wip' gibi, asl\u0131nda kavgada bile yap\u0131lmayacak hareketleri yapm\u0131\u015f\u0131zd\u0131r. Neden? Kim onca de\u011fi\u015fikli\u011fi oturup yazacak \u015fimdi? \u0130\u015fte en az\u0131ndan bu durumlar\u0131 minimal d\u00fczeye indirmek i\u00e7in tavsiye edilen ilk y\u00f6ntem: git commit ile commit yapmak, git commit -m 'MESAJ' kullanmamak! Bu y\u00f6ntemle kar\u015f\u0131m\u0131za git config core.editor ile belirlenmi\u015f text edit\u00f6r\u00fc \u00e7\u0131kar ve ferah fezah mesaj yazacak bir alanla kar\u015f\u0131 kar\u015f\u0131ya kal\u0131r\u0131z. B\u00f6yle bir durumda otomatikle\u015ftirilmi\u015f \u015fablon mesaj \u00e7ok i\u015fimize yarayabilir.","title":"Commit Mesaj\u0131 Nedir?"},{"location":"bolum-01/14-iyi-bir-commit-mesaji-nasil-olmali/","text":"\u0130yi Bir Commit Mesaj\u0131 Nas\u0131l Olmal\u0131? Bence temel kurallar; \u0130lk sat\u0131rda ( 50 karakteri ge\u00e7meden ) \u00f6zet bilgi vermek Detaylar\u0131 bir bo\u015f sat\u0131r b\u0131rak\u0131p alta yazmak Mutlaka yap\u0131lan de\u011fi\u015fiklileri iyi izah etmek \u015eu mesaj \u00f6rne\u011fine bakal\u0131m: Sitemizin yeni b \u00f6 l \u00fc m \u00fc i \u00e7 in index sayfas\u0131 olu \u015f turuldu . Yapt\u0131 \u011f \u0131m\u0131z projede , ABCD b \u00f6 l \u00fc m \u00fc i \u00e7 in yeni statik bir html sayfas\u0131 gerekiyordu , bunun i \u00e7 in index . html dosyas\u0131n\u0131 olu \u015f turdum ve front - end \u2019 i yazacak arkada \u015f lara gerekli bilgiyi verdim . Yeni bir paragrafta\u0131 ayn\u0131 markdown kullan\u0131r gibi kulland\u0131m . - Bu \u015f ekilde list item yapt\u0131m , - Listeye devam ettim Bu konu ile ilgili ticket \u2019 lar : - http : // example . com / ticket / 1 - http : // example . com / ticket / 2 # Please enter the commit message for your changes . Lines starting # with ' # ' will be ignored , and an empty message aborts the commit . # On branch master # # Initial commit # # Changes to be committed : # new file : index . html # K\u0131sa log\u2019a bakan kullan\u0131c\u0131; $ git log --oneline 8833c9cfc Sitemizin yeni b\u00f6l\u00fcm\u00fc i\u00e7in index sayfas\u0131 olu\u015fturuldu. : : \u015feklinde g\u00f6recek. Gayet a\u00e7\u0131klay\u0131c\u0131 oldu\u011funu d\u00fc\u015f\u00fcn\u00fcyorum. Detaylar\u0131 merak eden olursa yukar\u0131da yazan hikayeyi okuyabilir, hangi issue/ticket ile alakal\u0131 oldu\u011funu g\u00f6rebilir. Mesaj\u0131 i\u00e7inde # ile ba\u015flayan sat\u0131rlar yorum sat\u0131rlar\u0131d\u0131r. Mesaja dahil olmazlar. git commit dedikten sonra, gelen ekranda hi\u00e7bir \u015fey yazmadan \u00e7\u0131karsan\u0131z commit yapmaktan vazge\u00e7mi\u015f olursunuz: Aborting commit due to empty commit message. mesaj\u0131n\u0131 al\u0131rs\u0131n\u0131z. Yani bo\u015f mesaj olamaz! ( Baz\u0131 \u00f6zel durumlar d\u0131\u015f\u0131nda... )","title":"\u0130yi Bir Commit Mesaj\u0131 Nas\u0131l Olmal\u0131?"},{"location":"bolum-01/14-iyi-bir-commit-mesaji-nasil-olmali/#iyi-bir-commit-mesaj-nasl-olmal","text":"Bence temel kurallar; \u0130lk sat\u0131rda ( 50 karakteri ge\u00e7meden ) \u00f6zet bilgi vermek Detaylar\u0131 bir bo\u015f sat\u0131r b\u0131rak\u0131p alta yazmak Mutlaka yap\u0131lan de\u011fi\u015fiklileri iyi izah etmek \u015eu mesaj \u00f6rne\u011fine bakal\u0131m: Sitemizin yeni b \u00f6 l \u00fc m \u00fc i \u00e7 in index sayfas\u0131 olu \u015f turuldu . Yapt\u0131 \u011f \u0131m\u0131z projede , ABCD b \u00f6 l \u00fc m \u00fc i \u00e7 in yeni statik bir html sayfas\u0131 gerekiyordu , bunun i \u00e7 in index . html dosyas\u0131n\u0131 olu \u015f turdum ve front - end \u2019 i yazacak arkada \u015f lara gerekli bilgiyi verdim . Yeni bir paragrafta\u0131 ayn\u0131 markdown kullan\u0131r gibi kulland\u0131m . - Bu \u015f ekilde list item yapt\u0131m , - Listeye devam ettim Bu konu ile ilgili ticket \u2019 lar : - http : // example . com / ticket / 1 - http : // example . com / ticket / 2 # Please enter the commit message for your changes . Lines starting # with ' # ' will be ignored , and an empty message aborts the commit . # On branch master # # Initial commit # # Changes to be committed : # new file : index . html # K\u0131sa log\u2019a bakan kullan\u0131c\u0131; $ git log --oneline 8833c9cfc Sitemizin yeni b\u00f6l\u00fcm\u00fc i\u00e7in index sayfas\u0131 olu\u015fturuldu. : : \u015feklinde g\u00f6recek. Gayet a\u00e7\u0131klay\u0131c\u0131 oldu\u011funu d\u00fc\u015f\u00fcn\u00fcyorum. Detaylar\u0131 merak eden olursa yukar\u0131da yazan hikayeyi okuyabilir, hangi issue/ticket ile alakal\u0131 oldu\u011funu g\u00f6rebilir. Mesaj\u0131 i\u00e7inde # ile ba\u015flayan sat\u0131rlar yorum sat\u0131rlar\u0131d\u0131r. Mesaja dahil olmazlar. git commit dedikten sonra, gelen ekranda hi\u00e7bir \u015fey yazmadan \u00e7\u0131karsan\u0131z commit yapmaktan vazge\u00e7mi\u015f olursunuz: Aborting commit due to empty commit message. mesaj\u0131n\u0131 al\u0131rs\u0131n\u0131z. Yani bo\u015f mesaj olamaz! ( Baz\u0131 \u00f6zel durumlar d\u0131\u015f\u0131nda... )","title":"\u0130yi Bir Commit Mesaj\u0131 Nas\u0131l Olmal\u0131?"},{"location":"bolum-01/15-basit-kullanim-ornegi/","text":"Basit Kullan\u0131m \u00d6rne\u011fi GIT 146 \u2019dan fazla komut i\u00e7ermektedir. Bunlar\u0131n baz\u0131lar\u0131 g\u00fcnde sadece 1-2 kere, baz\u0131lar\u0131 40-50 kere, baz\u0131lar\u0131 da ayda-y\u0131lda belki 1 kere kullanaca\u011f\u0131n\u0131z komutlar olacakt\u0131r. E\u011fer; git help everyday derseniz, kar\u015f\u0131n\u0131za bir geli\u015ftiricinin ortalama kullanaca\u011f\u0131 komutlar\u0131, nas\u0131l kullanaca\u011f\u0131 bilgisini ve g\u00fcnl\u00fck rutin i\u015flerinizde size yard\u0131mc\u0131 olabilecek \u00e7al\u0131\u015fma y\u00f6ntemlerini g\u00f6steren harika bir yard\u0131m sayfas\u0131 gelir. Kabaca bak\u0131ld\u0131\u011f\u0131nda; git init git log git status git checkout git add git reset git commit git pull git push en s\u0131k kullanaca\u011f\u0131n\u0131z komutlardan olacakt\u0131r. Hemen s\u0131f\u0131rdan yeni bir repo olu\u015ftural\u0131m: $ cd /tmp/ $ git init git-basics && cd $_ Initialized empty Git repository in /private/tmp/git-basics/.git/ $ git commit --allow-empty -m '[root] Initial commit' [ master ( root-commit ) 7639a730f5c7 ] [ root ] Initial commit \u015eimdi i\u00e7ine bir dosya atal\u0131m ve reponun durumuna bakal\u0131m: git status $ touch README.md $ git status On branch master Untracked files: ( use \"git add <file>...\" to include in what will be committed ) README.md nothing added to commit but untracked files present ( use \"git add\" to track ) Takip d\u0131\u015f\u0131nda dosyalar var! ( Untracked files ) E\u011fer bu dosyalar\u0131 takip alt\u0131na almak isterseniz: git add <file> yap\u0131n... Peki yapal\u0131m: git add $ git add README.md $ git status On branch master Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) new file: README.md GIT, yeni bir dosya takip etmeye ba\u015flad\u0131\u011f\u0131n\u0131 anlad\u0131. \u00c7\u00fcnk\u00fc biz git add ile emir verdik GIT\u2019e. Dikkat ettiyseniz \u015f\u00f6yle bir uyar\u0131 var: (use \"git reset HEAD <file>...\" to unstage) git add README.md dedi\u011fimiz anda, README.md dosyas\u0131n\u0131 STAGING AREA yani sahneye alm\u0131\u015f olduk. Sahneye al\u0131nan her dosya commit edilebilir hale gelir. Bu dosyan\u0131n i\u00e7eri\u011fi GIT\u2019in index mekanizmas\u0131na eklenmi\u015ftir. Bu i\u015flem STAGING olarak da bilinir. E\u011fer hen\u00fcz bu dosyay\u0131 takibe almak istemiyor ya da de\u011fi\u015fikli\u011fi geri almak istiyorsan\u0131z git reset HEAD README.md yap\u0131p sahneden a\u015fa\u011f\u0131 indirmeniz yani UNSTAGE etmeniz gerekir. Bu noktada iki yeni kavram \u00e7\u0131kar kar\u015f\u0131m\u0131za. HEAD ve git reset . HEAD HEAD asl\u0131nda bir k\u0131sayol yani alias\u2019d\u0131r. Bulundu\u011funuz branch\u2019deki en yeni / en son commit\u2019i i\u015faret eder. \u015eimdi \u00f6rne\u011fe d\u00f6n\u00fcp hi\u00e7bir commit yapmadan git log --oneline dersek: $ git log --oneline * 7639a730f5c7 ( HEAD -> master ) [ root ] Initial commit HEAD \u2019in master branch\u2019de commit id\u2019si 7639a730f5c7 olan\u0131 i\u015faret etti\u011fini g\u00f6r\u00fcrs\u00fcn\u00fcz. Haydi yeni bir \u015fey daha... COMMIT ID GIT, mutlaka her commit\u2019e d\u00fcnyada e\u015fi benzeri olmayan bir ID verir. Asl\u0131nda 7639a730f5c7 diye g\u00f6rd\u00fc\u011f\u00fcm\u00fcz \u015fey; 7639a730f5c7979ca8a5ecaed3731e0e360f280a say\u0131s\u0131n\u0131n ilk 12 karakteridir. Bu k\u0131sa haline Short-SHA1 ( K\u0131sa SHA1 ) denir. K\u0131sa SHA1\u2019in uzun halini bulmak i\u00e7in; $ git rev-parse 7639a730f5c7 # 12 karater $ git rev-parse 7639a7 # 6 karakter yapmak yeterlidir. Uzun SHA1\u2019in ilk 6 ya da 7 karakteri de i\u015f g\u00f6r\u00fcr... COMMIT ID ayn\u0131 zamanda o an\u0131 ifade etti\u011fi i\u00e7in ilgili revizyonu da ifade eder. Her commit\u2019in tekil olmas\u0131 zorunlulu\u011fu, GIT\u2019in da\u011f\u0131t\u0131k \u00e7al\u0131\u015fmas\u0131 i\u00e7in zorunludur. Bir tak\u0131mda N tane ki\u015fi ayn\u0131 dosyalarla \u00e7al\u0131\u015facak ve hepsinde projenin bir kopyas\u0131 olacak. Keza hi\u00e7biri de internete ba\u011fl\u0131 olma zorunlulu\u011fu olmadan \u00e7al\u0131\u015facak. Bu bak\u0131mdan her yap\u0131lan commit\u2019in ba\u015fka commit\u2019lerle kar\u0131\u015fmamas\u0131 ve unique olmas\u0131 gerekiyor. \u0130\u015fte GIT\u2019in en ayr\u0131\u015ft\u0131r\u0131c\u0131 \u00f6zelli\u011fi de bu. Tekrar \u00f6rne\u011fe d\u00f6nelim. GIT bize bilgi verdi ya, e\u011fer istersek git reset yapar\u0131z. \u0130leriki b\u00f6l\u00fcmlerde daha detayl\u0131 de\u011finece\u011fim ama \u015fimdi yeri gelmi\u015fken h\u0131zl\u0131ca a\u00e7\u0131klamaya \u00e7al\u0131\u015fay\u0131m. git reset REV\u0130ZYON DOSYA kullan\u0131m \u015fekillerinden biridir. HEAD neyi i\u015faret ediyordu? 7639a730f5c7 numaral\u0131 commit\u2019i. Bu revizyonda README.md diye bir dosya var m\u0131yd\u0131? $ git reset HEAD README.md $ git status On branch master Untracked files: ( use \"git add <file>...\" to include in what will be committed ) README.md nothing added to commit but untracked files present ( use \"git add\" to track ) Hay\u0131r, takip alt\u0131nda b\u00f6yle bir dosya yoktu. Tekrar ba\u015flad\u0131\u011f\u0131m\u0131z yere d\u00f6nd\u00fck... \u015eimdi tekrar ekleme i\u015fini yapal\u0131m ve ard\u0131ndan da ilk commit\u2019i yapal\u0131m: $ git add README.md $ git commit -m 'Added: readme file' [ master 6601df828690 ] Added: readme file 1 file changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 README.md Commit ba\u015far\u0131yla ger\u00e7ekle\u015fti. GIT yeni unique ( benzersiz ) bir ID verdi, 6601df828690 ek olarak 1 dosyan\u0131n eklendi\u011fini, dosya i\u00e7inde metinsel herhangi bir de\u011fi\u015fiklik olmad\u0131\u011f\u0131n\u0131 s\u00f6yledi. 0 insertions(+), 0 deletions(-) Peki \u015fimdi durum ne? $ git status On branch master nothing to commit, working tree clean master branch\u2019deyiz, her \u015fey yolunda!. git add kullan\u0131rken; # git add <DOSYA> $ git add README.md # git add <D\u0130Z\u0130N> $ git add images/ # git add . # bulundu\u011fun dizindeki her \u015feyi # . unix ifadesidir ve current working directory\u2019i ifade eder. $ git add . # git add *.py # foo.py import.py run.py gibi sonu .py ile biten dosyalar\u0131 ekler $ git add *.py # git add test-*.txt # test-foo1.txt test-foo2.txt test-hello-world.txt gibi $ git add test-*.txt yapmak m\u00fcmk\u00fcn. \u0130\u015flem s\u0131ras\u0131 olarak \u00f6nce add sonra commit yapt\u0131k. Bu s\u00fcreci tek harekete indirmek m\u00fcmk\u00fcn: $ git commit -a -m 'Added: all untracked files at once' commit -a ile t\u00fcm untracked ( hen\u00fcz takibe al\u0131nmam\u0131\u015f ) olan dosya/dizin ne varsa staging \u2019e at diyoruz. -m de tabiki commit mesaj\u0131. Ben bu y\u00f6ntemi neredeyse hi\u00e7 kullanm\u0131yorum. Mutlaka ilgili dosyalar\u0131 ekleyip daha sonra commit ediyorum.","title":"Basit Kullan\u0131m \u00d6rne\u011fi"},{"location":"bolum-01/15-basit-kullanim-ornegi/#basit-kullanm-ornegi","text":"GIT 146 \u2019dan fazla komut i\u00e7ermektedir. Bunlar\u0131n baz\u0131lar\u0131 g\u00fcnde sadece 1-2 kere, baz\u0131lar\u0131 40-50 kere, baz\u0131lar\u0131 da ayda-y\u0131lda belki 1 kere kullanaca\u011f\u0131n\u0131z komutlar olacakt\u0131r. E\u011fer; git help everyday derseniz, kar\u015f\u0131n\u0131za bir geli\u015ftiricinin ortalama kullanaca\u011f\u0131 komutlar\u0131, nas\u0131l kullanaca\u011f\u0131 bilgisini ve g\u00fcnl\u00fck rutin i\u015flerinizde size yard\u0131mc\u0131 olabilecek \u00e7al\u0131\u015fma y\u00f6ntemlerini g\u00f6steren harika bir yard\u0131m sayfas\u0131 gelir. Kabaca bak\u0131ld\u0131\u011f\u0131nda; git init git log git status git checkout git add git reset git commit git pull git push en s\u0131k kullanaca\u011f\u0131n\u0131z komutlardan olacakt\u0131r. Hemen s\u0131f\u0131rdan yeni bir repo olu\u015ftural\u0131m: $ cd /tmp/ $ git init git-basics && cd $_ Initialized empty Git repository in /private/tmp/git-basics/.git/ $ git commit --allow-empty -m '[root] Initial commit' [ master ( root-commit ) 7639a730f5c7 ] [ root ] Initial commit \u015eimdi i\u00e7ine bir dosya atal\u0131m ve reponun durumuna bakal\u0131m: git status $ touch README.md $ git status On branch master Untracked files: ( use \"git add <file>...\" to include in what will be committed ) README.md nothing added to commit but untracked files present ( use \"git add\" to track ) Takip d\u0131\u015f\u0131nda dosyalar var! ( Untracked files ) E\u011fer bu dosyalar\u0131 takip alt\u0131na almak isterseniz: git add <file> yap\u0131n... Peki yapal\u0131m: git add $ git add README.md $ git status On branch master Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) new file: README.md GIT, yeni bir dosya takip etmeye ba\u015flad\u0131\u011f\u0131n\u0131 anlad\u0131. \u00c7\u00fcnk\u00fc biz git add ile emir verdik GIT\u2019e. Dikkat ettiyseniz \u015f\u00f6yle bir uyar\u0131 var: (use \"git reset HEAD <file>...\" to unstage) git add README.md dedi\u011fimiz anda, README.md dosyas\u0131n\u0131 STAGING AREA yani sahneye alm\u0131\u015f olduk. Sahneye al\u0131nan her dosya commit edilebilir hale gelir. Bu dosyan\u0131n i\u00e7eri\u011fi GIT\u2019in index mekanizmas\u0131na eklenmi\u015ftir. Bu i\u015flem STAGING olarak da bilinir. E\u011fer hen\u00fcz bu dosyay\u0131 takibe almak istemiyor ya da de\u011fi\u015fikli\u011fi geri almak istiyorsan\u0131z git reset HEAD README.md yap\u0131p sahneden a\u015fa\u011f\u0131 indirmeniz yani UNSTAGE etmeniz gerekir. Bu noktada iki yeni kavram \u00e7\u0131kar kar\u015f\u0131m\u0131za. HEAD ve git reset .","title":"Basit Kullan\u0131m \u00d6rne\u011fi"},{"location":"bolum-01/15-basit-kullanim-ornegi/#head","text":"HEAD asl\u0131nda bir k\u0131sayol yani alias\u2019d\u0131r. Bulundu\u011funuz branch\u2019deki en yeni / en son commit\u2019i i\u015faret eder. \u015eimdi \u00f6rne\u011fe d\u00f6n\u00fcp hi\u00e7bir commit yapmadan git log --oneline dersek: $ git log --oneline * 7639a730f5c7 ( HEAD -> master ) [ root ] Initial commit HEAD \u2019in master branch\u2019de commit id\u2019si 7639a730f5c7 olan\u0131 i\u015faret etti\u011fini g\u00f6r\u00fcrs\u00fcn\u00fcz. Haydi yeni bir \u015fey daha...","title":"HEAD"},{"location":"bolum-01/15-basit-kullanim-ornegi/#commit-id","text":"GIT, mutlaka her commit\u2019e d\u00fcnyada e\u015fi benzeri olmayan bir ID verir. Asl\u0131nda 7639a730f5c7 diye g\u00f6rd\u00fc\u011f\u00fcm\u00fcz \u015fey; 7639a730f5c7979ca8a5ecaed3731e0e360f280a say\u0131s\u0131n\u0131n ilk 12 karakteridir. Bu k\u0131sa haline Short-SHA1 ( K\u0131sa SHA1 ) denir. K\u0131sa SHA1\u2019in uzun halini bulmak i\u00e7in; $ git rev-parse 7639a730f5c7 # 12 karater $ git rev-parse 7639a7 # 6 karakter yapmak yeterlidir. Uzun SHA1\u2019in ilk 6 ya da 7 karakteri de i\u015f g\u00f6r\u00fcr... COMMIT ID ayn\u0131 zamanda o an\u0131 ifade etti\u011fi i\u00e7in ilgili revizyonu da ifade eder. Her commit\u2019in tekil olmas\u0131 zorunlulu\u011fu, GIT\u2019in da\u011f\u0131t\u0131k \u00e7al\u0131\u015fmas\u0131 i\u00e7in zorunludur. Bir tak\u0131mda N tane ki\u015fi ayn\u0131 dosyalarla \u00e7al\u0131\u015facak ve hepsinde projenin bir kopyas\u0131 olacak. Keza hi\u00e7biri de internete ba\u011fl\u0131 olma zorunlulu\u011fu olmadan \u00e7al\u0131\u015facak. Bu bak\u0131mdan her yap\u0131lan commit\u2019in ba\u015fka commit\u2019lerle kar\u0131\u015fmamas\u0131 ve unique olmas\u0131 gerekiyor. \u0130\u015fte GIT\u2019in en ayr\u0131\u015ft\u0131r\u0131c\u0131 \u00f6zelli\u011fi de bu. Tekrar \u00f6rne\u011fe d\u00f6nelim. GIT bize bilgi verdi ya, e\u011fer istersek git reset yapar\u0131z. \u0130leriki b\u00f6l\u00fcmlerde daha detayl\u0131 de\u011finece\u011fim ama \u015fimdi yeri gelmi\u015fken h\u0131zl\u0131ca a\u00e7\u0131klamaya \u00e7al\u0131\u015fay\u0131m. git reset REV\u0130ZYON DOSYA kullan\u0131m \u015fekillerinden biridir. HEAD neyi i\u015faret ediyordu? 7639a730f5c7 numaral\u0131 commit\u2019i. Bu revizyonda README.md diye bir dosya var m\u0131yd\u0131? $ git reset HEAD README.md $ git status On branch master Untracked files: ( use \"git add <file>...\" to include in what will be committed ) README.md nothing added to commit but untracked files present ( use \"git add\" to track ) Hay\u0131r, takip alt\u0131nda b\u00f6yle bir dosya yoktu. Tekrar ba\u015flad\u0131\u011f\u0131m\u0131z yere d\u00f6nd\u00fck... \u015eimdi tekrar ekleme i\u015fini yapal\u0131m ve ard\u0131ndan da ilk commit\u2019i yapal\u0131m: $ git add README.md $ git commit -m 'Added: readme file' [ master 6601df828690 ] Added: readme file 1 file changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 README.md Commit ba\u015far\u0131yla ger\u00e7ekle\u015fti. GIT yeni unique ( benzersiz ) bir ID verdi, 6601df828690 ek olarak 1 dosyan\u0131n eklendi\u011fini, dosya i\u00e7inde metinsel herhangi bir de\u011fi\u015fiklik olmad\u0131\u011f\u0131n\u0131 s\u00f6yledi. 0 insertions(+), 0 deletions(-) Peki \u015fimdi durum ne? $ git status On branch master nothing to commit, working tree clean master branch\u2019deyiz, her \u015fey yolunda!. git add kullan\u0131rken; # git add <DOSYA> $ git add README.md # git add <D\u0130Z\u0130N> $ git add images/ # git add . # bulundu\u011fun dizindeki her \u015feyi # . unix ifadesidir ve current working directory\u2019i ifade eder. $ git add . # git add *.py # foo.py import.py run.py gibi sonu .py ile biten dosyalar\u0131 ekler $ git add *.py # git add test-*.txt # test-foo1.txt test-foo2.txt test-hello-world.txt gibi $ git add test-*.txt yapmak m\u00fcmk\u00fcn. \u0130\u015flem s\u0131ras\u0131 olarak \u00f6nce add sonra commit yapt\u0131k. Bu s\u00fcreci tek harekete indirmek m\u00fcmk\u00fcn: $ git commit -a -m 'Added: all untracked files at once' commit -a ile t\u00fcm untracked ( hen\u00fcz takibe al\u0131nmam\u0131\u015f ) olan dosya/dizin ne varsa staging \u2019e at diyoruz. -m de tabiki commit mesaj\u0131. Ben bu y\u00f6ntemi neredeyse hi\u00e7 kullanm\u0131yorum. Mutlaka ilgili dosyalar\u0131 ekleyip daha sonra commit ediyorum.","title":"COMMIT ID"},{"location":"bolum-01/16-uc-asamali-dosya-sistemi/","text":"\u00dc\u00e7 A\u015famal\u0131 Dosya Sistemi GIT ile \u00e7al\u0131\u015f\u0131rken 3 a\u015famal\u0131 dosya sistemini hep akl\u0131m\u0131zda tutmal\u0131y\u0131z: Staged Modified Commited Staged Baz\u0131 de\u011fi\u015fiklikler ya da eklemeler yapt\u0131n, sepete att\u0131n ama hen\u00fcz GIT\u2019e bildirmedin! Yani sahneye ald\u0131n fakat \u00f6ylece duruyor orada. Modified De\u011fi\u015fiklikler var, GIT bunun fark\u0131nda ama hen\u00fcz kaydetmedin yani commit etmedin! Bu ne demek? Hemen bakal\u0131m: $ ls README.md file-info-1.txt file-info-2.txt file1.txt file2.txt \u015eimdi file-info-2.txt \u00fczerinde de\u011fi\u015fiklik yapal\u0131m. $ echo 'adding another great line' >> file-info-2.txt $ git status On branch master Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git checkout -- <file>...\" to discard changes in working directory ) modified: file-info-2.txt no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) GIT, de\u011fi\u015fikli\u011fi anlad\u0131, bu dosyan\u0131n de\u011fi\u015fti\u011fini yani modified oldu\u011funu s\u00f6yl\u00fcyor. De\u011fi\u015fikli\u011fi geri almak i\u00e7in git checkout -- <file> yapabiliriz. Acaba file-info-2.txt i\u00e7inde ne yaz\u0131yor? $ cat file-info-2.txt file information 2 adding another great line Hmmm... peki alal\u0131m geri: $ git checkout -- file-info-2.txt $ git status On branch master nothing to commit, working tree clean Dosyan\u0131n i\u00e7eri\u011fi? $ cat file-info-2.txt file information 2 \u015eimdi biraz daha de\u011fi\u015fik bir \u015fey deneyelim. Tekrar ayn\u0131 i\u015flemi yapal\u0131m ama k\u00fc\u00e7\u00fck bir farkla: $ echo 'adding another great line' >> file-info-2.txt $ git add file-info-2.txt $ echo 'adding another great line for the 3rd time' >> file-info-2.txt $ git status On branch master Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) modified: file-info-2.txt Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git checkout -- <file>...\" to discard changes in working directory ) modified: file-info-2.txt Durum \u015fu; file-info-2.txt dosyas\u0131 sanki 2 kere modified yani de\u011fi\u015fikli\u011fi u\u011fram\u0131\u015f ama birinde staged , di\u011ferinde ise modified . Evet aynen de b\u00f6yle oldu. De\u011fi\u015fiklik yapt\u0131k ve git add ile staging\u2019e ald\u0131k, commit yapmad\u0131k ve tekrar de\u011fi\u015fiklik yapt\u0131k... Tekrar ekleyelim ki bu ikinci de\u011fi\u015fiklik de kay\u0131t alt\u0131na al\u0131ns\u0131n: $ git add file-info-2.txt $ git status On branch master Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) modified: file-info-2.txt Committed Veri, yerel veritaban\u0131na g\u00fcvenli olarak kaydedildi. Neticede GIT kendi yerelinde, kendi anlayaca\u011f\u0131 \u015fekilde bir veritaban\u0131 sakl\u0131yor. \u015eimdi yukar\u0131da yar\u0131m kalan i\u015fi bitirelim: $ git commit -m 'staged, modifed and commited example' [ master 5fe19937b38f ] staged, modifed and commited example 1 file changed, 2 insertions ( + ) $ git log --oneline 5fe19937b38f staged, modifed and commited example 5579b829b6a8 file added via git add -p c52805a3c8f5 added two info files for demo purposes bb965e45b9ca Both files are added via git add -i 6601df828690 Added: readme file 7639a730f5c7 [ root ] Initial commit","title":"\u00dc\u00e7 A\u015famal\u0131 Dosya Sistemi"},{"location":"bolum-01/16-uc-asamali-dosya-sistemi/#uc-asamal-dosya-sistemi","text":"GIT ile \u00e7al\u0131\u015f\u0131rken 3 a\u015famal\u0131 dosya sistemini hep akl\u0131m\u0131zda tutmal\u0131y\u0131z: Staged Modified Commited","title":"\u00dc\u00e7 A\u015famal\u0131 Dosya Sistemi"},{"location":"bolum-01/16-uc-asamali-dosya-sistemi/#staged","text":"Baz\u0131 de\u011fi\u015fiklikler ya da eklemeler yapt\u0131n, sepete att\u0131n ama hen\u00fcz GIT\u2019e bildirmedin! Yani sahneye ald\u0131n fakat \u00f6ylece duruyor orada.","title":"Staged"},{"location":"bolum-01/16-uc-asamali-dosya-sistemi/#modified","text":"De\u011fi\u015fiklikler var, GIT bunun fark\u0131nda ama hen\u00fcz kaydetmedin yani commit etmedin! Bu ne demek? Hemen bakal\u0131m: $ ls README.md file-info-1.txt file-info-2.txt file1.txt file2.txt \u015eimdi file-info-2.txt \u00fczerinde de\u011fi\u015fiklik yapal\u0131m. $ echo 'adding another great line' >> file-info-2.txt $ git status On branch master Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git checkout -- <file>...\" to discard changes in working directory ) modified: file-info-2.txt no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) GIT, de\u011fi\u015fikli\u011fi anlad\u0131, bu dosyan\u0131n de\u011fi\u015fti\u011fini yani modified oldu\u011funu s\u00f6yl\u00fcyor. De\u011fi\u015fikli\u011fi geri almak i\u00e7in git checkout -- <file> yapabiliriz. Acaba file-info-2.txt i\u00e7inde ne yaz\u0131yor? $ cat file-info-2.txt file information 2 adding another great line Hmmm... peki alal\u0131m geri: $ git checkout -- file-info-2.txt $ git status On branch master nothing to commit, working tree clean Dosyan\u0131n i\u00e7eri\u011fi? $ cat file-info-2.txt file information 2 \u015eimdi biraz daha de\u011fi\u015fik bir \u015fey deneyelim. Tekrar ayn\u0131 i\u015flemi yapal\u0131m ama k\u00fc\u00e7\u00fck bir farkla: $ echo 'adding another great line' >> file-info-2.txt $ git add file-info-2.txt $ echo 'adding another great line for the 3rd time' >> file-info-2.txt $ git status On branch master Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) modified: file-info-2.txt Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git checkout -- <file>...\" to discard changes in working directory ) modified: file-info-2.txt Durum \u015fu; file-info-2.txt dosyas\u0131 sanki 2 kere modified yani de\u011fi\u015fikli\u011fi u\u011fram\u0131\u015f ama birinde staged , di\u011ferinde ise modified . Evet aynen de b\u00f6yle oldu. De\u011fi\u015fiklik yapt\u0131k ve git add ile staging\u2019e ald\u0131k, commit yapmad\u0131k ve tekrar de\u011fi\u015fiklik yapt\u0131k... Tekrar ekleyelim ki bu ikinci de\u011fi\u015fiklik de kay\u0131t alt\u0131na al\u0131ns\u0131n: $ git add file-info-2.txt $ git status On branch master Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) modified: file-info-2.txt","title":"Modified"},{"location":"bolum-01/16-uc-asamali-dosya-sistemi/#committed","text":"Veri, yerel veritaban\u0131na g\u00fcvenli olarak kaydedildi. Neticede GIT kendi yerelinde, kendi anlayaca\u011f\u0131 \u015fekilde bir veritaban\u0131 sakl\u0131yor. \u015eimdi yukar\u0131da yar\u0131m kalan i\u015fi bitirelim: $ git commit -m 'staged, modifed and commited example' [ master 5fe19937b38f ] staged, modifed and commited example 1 file changed, 2 insertions ( + ) $ git log --oneline 5fe19937b38f staged, modifed and commited example 5579b829b6a8 file added via git add -p c52805a3c8f5 added two info files for demo purposes bb965e45b9ca Both files are added via git add -i 6601df828690 Added: readme file 7639a730f5c7 [ root ] Initial commit","title":"Committed"},{"location":"bolum-01/17-interaktif-git-add/","text":"\u0130nteraktif Ekleme: git add -i E\u011fer git add -i derseniz, Interactive Mode \u2019a ge\u00e7ersiniz. Bu durumda kar\u015f\u0131n\u0131za \u00e7e\u015fitli se\u00e7enekler \u00e7\u0131kar: $ touch file { 1 ,2 } .txt $ ls -al total 0 drwxr-xr-x 6 vigo wheel 204 Jun 25 19 :48 . drwxrwxrwt 59 root wheel 2006 Jun 25 19 :39 .. drwxr-xr-x 14 vigo wheel 476 Jun 25 19 :48 .git -rw-r--r-- 1 vigo wheel 0 Jun 25 18 :53 README.md -rw-r--r-- 1 vigo wheel 0 Jun 25 19 :48 file1.txt -rw-r--r-- 1 vigo wheel 0 Jun 25 19 :48 file2.txt $ git status On branch master Untracked files: ( use \"git add <file>...\" to include in what will be committed ) file1.txt file2.txt nothing added to commit but untracked files present ( use \"git add\" to track ) $ git add -i *** Commands *** 1 : status 2 : update 3 : revert 4 : add untracked 5 : patch 6 : diff 7 : quit 8 : help What now> Evet, \u015fimdi ne yapaca\u011f\u0131z? 4 yani takip d\u0131\u015f\u0131ndakileri ekleyelim. 1: file1.txt 2: file2.txt Add untracked>> Bu durumda ya 1,2 yaz\u0131p iki dosyay\u0131 da ekleyece\u011fiz ya da teker teker ilerleyece\u011fiz. Ben 1,2 yazd\u0131m: * 1: file1.txt * 2: file2.txt Add untracked>> * bunlar\u0131 i\u015fleme girdi\u011fini belirtiyor. Tekrar <ENTER> yap\u0131p ilerliyorum: Add untracked>> added 2 paths *** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: help What now> \u0130\u015fim bitti, 7 ile \u00e7\u0131k\u0131yorum ve duruma bak\u0131yorum: git status : On branch master Changes to be committed: (use \"git reset HEAD <file>...\" to unstage) new file: file1.txt new file: file2.txt \u015eimdi commit zaman\u0131... $ git commit -m 'Both files are added via git add -i' [ master bb965e45b9ca ] Both files are added via git add -i 2 files changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 file1.txt create mode 100644 file2.txt \u0130nteraktif modda, oldu ya son anda dosyay\u0131 eklemekten vazge\u00e7tiniz; $ touch file3.txt && git add -i *** Commands *** 1 : status 2 : update 3 : revert 4 : add untracked 5 : patch 6 : diff 7 : quit 8 : help What now> 4 1 : file3.txt Add untracked>> 1 * 1 : file3.txt Add untracked>> - ile \u00e7\u0131kartabilirsiniz. -1 ya da -INDEKS_NO . Add untracked>> -1 1: file3.txt Add untracked>> <ENTER> Add untracked>> No untracked files. *** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: help What now> 7 Bye.","title":"\u0130nteraktif Ekleme: `git add -i`"},{"location":"bolum-01/17-interaktif-git-add/#interaktif-ekleme-git-add-i","text":"E\u011fer git add -i derseniz, Interactive Mode \u2019a ge\u00e7ersiniz. Bu durumda kar\u015f\u0131n\u0131za \u00e7e\u015fitli se\u00e7enekler \u00e7\u0131kar: $ touch file { 1 ,2 } .txt $ ls -al total 0 drwxr-xr-x 6 vigo wheel 204 Jun 25 19 :48 . drwxrwxrwt 59 root wheel 2006 Jun 25 19 :39 .. drwxr-xr-x 14 vigo wheel 476 Jun 25 19 :48 .git -rw-r--r-- 1 vigo wheel 0 Jun 25 18 :53 README.md -rw-r--r-- 1 vigo wheel 0 Jun 25 19 :48 file1.txt -rw-r--r-- 1 vigo wheel 0 Jun 25 19 :48 file2.txt $ git status On branch master Untracked files: ( use \"git add <file>...\" to include in what will be committed ) file1.txt file2.txt nothing added to commit but untracked files present ( use \"git add\" to track ) $ git add -i *** Commands *** 1 : status 2 : update 3 : revert 4 : add untracked 5 : patch 6 : diff 7 : quit 8 : help What now> Evet, \u015fimdi ne yapaca\u011f\u0131z? 4 yani takip d\u0131\u015f\u0131ndakileri ekleyelim. 1: file1.txt 2: file2.txt Add untracked>> Bu durumda ya 1,2 yaz\u0131p iki dosyay\u0131 da ekleyece\u011fiz ya da teker teker ilerleyece\u011fiz. Ben 1,2 yazd\u0131m: * 1: file1.txt * 2: file2.txt Add untracked>> * bunlar\u0131 i\u015fleme girdi\u011fini belirtiyor. Tekrar <ENTER> yap\u0131p ilerliyorum: Add untracked>> added 2 paths *** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: help What now> \u0130\u015fim bitti, 7 ile \u00e7\u0131k\u0131yorum ve duruma bak\u0131yorum: git status : On branch master Changes to be committed: (use \"git reset HEAD <file>...\" to unstage) new file: file1.txt new file: file2.txt \u015eimdi commit zaman\u0131... $ git commit -m 'Both files are added via git add -i' [ master bb965e45b9ca ] Both files are added via git add -i 2 files changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 file1.txt create mode 100644 file2.txt \u0130nteraktif modda, oldu ya son anda dosyay\u0131 eklemekten vazge\u00e7tiniz; $ touch file3.txt && git add -i *** Commands *** 1 : status 2 : update 3 : revert 4 : add untracked 5 : patch 6 : diff 7 : quit 8 : help What now> 4 1 : file3.txt Add untracked>> 1 * 1 : file3.txt Add untracked>> - ile \u00e7\u0131kartabilirsiniz. -1 ya da -INDEKS_NO . Add untracked>> -1 1: file3.txt Add untracked>> <ENTER> Add untracked>> No untracked files. *** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: help What now> 7 Bye.","title":"\u0130nteraktif Ekleme: git add -i"},{"location":"bolum-01/18-patch-mod-git-add/","text":"Patch Mode\u2019da Ekleme: git add -p Belkide GIT\u2019in yap\u0131lma sebeplerinden biri Patching . Linus Torvalds, Linux kernel\u2019i geli\u015ftirirken, di\u011fer katk\u0131 yapan developerlar, yapt\u0131klar\u0131n\u0131 e-posta ile patch format\u0131nda yolluyorlarm\u0131\u015f. Bu e-postalarla m\u00fccadele etmek, gelenleri kontrol etmek, bir t\u00fcr review i\u015fleminden ge\u00e7irmek vs \u00e7ok zahmetli i\u015fler. GIT bu durum i\u00e7in \u00f6zel bir se\u00e7ene\u011fe sahip. $ echo 'file information 1' > file-info-1.txt $ echo 'file information 2' > file-info-2.txt $ ls README.md file-info-1.txt file-info-2.txt file1.txt file2.txt $ git add . $ git status On branch master Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) new file: file-info-1.txt new file: file-info-2.txt $ git commit -m 'added two info files for demo purposes' \u015eimdi, file-info-1.txt dosyas\u0131na bir-ka\u00e7 sat\u0131r ekleyelim: $ echo 'added new line' >> file-info-1.txt $ echo 'added one more new line' >> file-info-1.txt $ git status On branch master Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git checkout -- <file>...\" to discard changes in working directory ) modified: file-info-1.txt no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) \u015eimdi patch mode\u2019a ge\u00e7elim: $ git add -p diff --git a/file-info-1.txt b/file-info-1.txt index 833822e8a04b..a333d502478e 100644 --- a/file-info-1.txt +++ b/file-info-1.txt @@ -1 +1,3 @@ file information 1 +added new line +added one more new line Stage this hunk [ y,n,q,a,d,/,e,? ] ? GIT, bildi\u011fi son hali ile yeni de\u011fi\u015fikli\u011fin aras\u0131n\u0131 bize diff ile g\u00f6steriyor ve soruyor. Bu hunk \u2019\u0131 yani par\u00e7ay\u0131 ne yapay\u0131m? y : YES, bu hunk\u2019\u0131 al. n : NO, bu hunk\u2019\u0131 alma. q : QUIT, hi\u00e7bir \u015fey yapmadan \u00e7\u0131k ve devam etme. a : ALL, bu hunk dahil, dosyadaki di\u011fer t\u00fcm hunk\u2019lar\u0131 al. d : DON\u2019T, bu hunk dahil, di\u011fer t\u00fcm hunk\u2019lar\u0131 alma. / : SEARCH, girilecek REGEX paternine g\u00f6re hunk ara. e : EDIT, elle hunk\u2019\u0131 d\u00fczenle. ? : HELP, yard\u0131m i\u00e7in. Ben a yap\u0131yorum ve git status : $ git status On branch master Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) modified: file-info-1.txt Bu y\u00f6ntem kodu tekrar g\u00f6zden ge\u00e7irme imkan\u0131 verdi\u011fi gibi, son dakikada bir \u015feyleri d\u00fczeltme de\u011fi\u015ftirme \u015fans\u0131 da veriyor. Bu patch modu asl\u0131nda \u00e7akt\u0131rmadan git add -i yap\u0131yor ve direk olarak oradaki patch se\u00e7ene\u011fini a\u00e7\u0131yor. Daha fazla bilgi almak i\u00e7in git help add demek m\u00fcmk\u00fcn.","title":"Patch Mode\u2019da Ekleme: `git add -p`"},{"location":"bolum-01/18-patch-mod-git-add/#patch-modeda-ekleme-git-add-p","text":"Belkide GIT\u2019in yap\u0131lma sebeplerinden biri Patching . Linus Torvalds, Linux kernel\u2019i geli\u015ftirirken, di\u011fer katk\u0131 yapan developerlar, yapt\u0131klar\u0131n\u0131 e-posta ile patch format\u0131nda yolluyorlarm\u0131\u015f. Bu e-postalarla m\u00fccadele etmek, gelenleri kontrol etmek, bir t\u00fcr review i\u015fleminden ge\u00e7irmek vs \u00e7ok zahmetli i\u015fler. GIT bu durum i\u00e7in \u00f6zel bir se\u00e7ene\u011fe sahip. $ echo 'file information 1' > file-info-1.txt $ echo 'file information 2' > file-info-2.txt $ ls README.md file-info-1.txt file-info-2.txt file1.txt file2.txt $ git add . $ git status On branch master Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) new file: file-info-1.txt new file: file-info-2.txt $ git commit -m 'added two info files for demo purposes' \u015eimdi, file-info-1.txt dosyas\u0131na bir-ka\u00e7 sat\u0131r ekleyelim: $ echo 'added new line' >> file-info-1.txt $ echo 'added one more new line' >> file-info-1.txt $ git status On branch master Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git checkout -- <file>...\" to discard changes in working directory ) modified: file-info-1.txt no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) \u015eimdi patch mode\u2019a ge\u00e7elim: $ git add -p diff --git a/file-info-1.txt b/file-info-1.txt index 833822e8a04b..a333d502478e 100644 --- a/file-info-1.txt +++ b/file-info-1.txt @@ -1 +1,3 @@ file information 1 +added new line +added one more new line Stage this hunk [ y,n,q,a,d,/,e,? ] ? GIT, bildi\u011fi son hali ile yeni de\u011fi\u015fikli\u011fin aras\u0131n\u0131 bize diff ile g\u00f6steriyor ve soruyor. Bu hunk \u2019\u0131 yani par\u00e7ay\u0131 ne yapay\u0131m? y : YES, bu hunk\u2019\u0131 al. n : NO, bu hunk\u2019\u0131 alma. q : QUIT, hi\u00e7bir \u015fey yapmadan \u00e7\u0131k ve devam etme. a : ALL, bu hunk dahil, dosyadaki di\u011fer t\u00fcm hunk\u2019lar\u0131 al. d : DON\u2019T, bu hunk dahil, di\u011fer t\u00fcm hunk\u2019lar\u0131 alma. / : SEARCH, girilecek REGEX paternine g\u00f6re hunk ara. e : EDIT, elle hunk\u2019\u0131 d\u00fczenle. ? : HELP, yard\u0131m i\u00e7in. Ben a yap\u0131yorum ve git status : $ git status On branch master Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) modified: file-info-1.txt Bu y\u00f6ntem kodu tekrar g\u00f6zden ge\u00e7irme imkan\u0131 verdi\u011fi gibi, son dakikada bir \u015feyleri d\u00fczeltme de\u011fi\u015ftirme \u015fans\u0131 da veriyor. Bu patch modu asl\u0131nda \u00e7akt\u0131rmadan git add -i yap\u0131yor ve direk olarak oradaki patch se\u00e7ene\u011fini a\u00e7\u0131yor. Daha fazla bilgi almak i\u00e7in git help add demek m\u00fcmk\u00fcn.","title":"Patch Mode\u2019da Ekleme: git add -p"},{"location":"bolum-01/19-reponun-durumu-git-status/","text":"Repo\u2019nun Durumu: git status Bu noktaya kadar pek \u00e7ok kez git status yapt\u0131k. Ek birka\u00e7 parametre ile de\u011fi\u015fik \u00e7\u0131kt\u0131lar almak m\u00fcmk\u00fcn: git status -s ve git status -sb Short Status yani k\u0131saca durum bilgisi i\u00e7in kullan\u0131l\u0131r. -b bulundu\u011fun branch\u2019i de g\u00f6ster anlam\u0131ndad\u0131r: $ git status -s M file1.txt AM new-file-1.txt A new-file-2.txt ?? new-file-3.txt $ git status -sb ## master M file1.txt AM new-file-1.txt A new-file-2.txt ?? new-file-3.txt Bu tek harflerin bir anlam\u0131 var. = unmodified, bo\u015fluk karakteri, de\u011fi\u015ftirilmemi\u015f M = modified, de\u011fi\u015fiklik var A = added, eklendi yani staged D = deleted, silindi R = renamed, dosya ad\u0131 de\u011fi\u015fti C = copied, kopyaland\u0131 U = updated but unmerged, index g\u00fcncellendi ama merge edilmedi git status --ignored E\u011fer exclude edilmi\u015f, yani tan\u0131mlanan dosyalar, dizinler, ya da dosya t\u00fcrlerini GIT takibe almas\u0131n demi\u015fsek, varsa bu t\u00fcr dosyalar, status i\u00e7inde bunlar\u0131 da g\u00f6ster demektir. Dosyalar\u0131 nas\u0131l takip d\u0131\u015f\u0131nda b\u0131rak\u0131r\u0131z? git status --untracked-files \u00d6rnek projede, git status dedi\u011fimiz zaman; $ git status On branch master Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) new file: new-file-1.txt new file: new-file-2.txt Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git checkout -- <file>...\" to discard changes in working directory ) modified: file1.txt modified: new-file-1.txt Untracked files: ( use \"git add <file>...\" to include in what will be committed ) new-file-3.txt test-folder/ g\u00f6r\u00fcyoruz. Bizi ilgilendiren k\u0131s\u0131m Untracked files: k\u0131sm\u0131 yani hen\u00fcz takip alt\u0131na al\u0131nmam\u0131\u015f dosyalar. Bir dosya bir de dizin g\u00f6r\u00fcyorum. Acaba bu dizin alt\u0131nda ba\u015fka dosya var m\u0131? $ git status --untracked-files On branch master Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) new file: new-file-1.txt new file: new-file-2.txt Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git checkout -- <file>...\" to discard changes in working directory ) modified: file1.txt modified: new-file-1.txt Untracked files: ( use \"git add <file>...\" to include in what will be committed ) new-file-3.txt test-folder/test-file-a.txt test-folder/test-file-b.txt test-folder/test-file-c.txt Tam \u00fc\u00e7 tane dosya varm\u0131\u015f!...","title":"Repo\u2019nun Durumu: `git status`"},{"location":"bolum-01/19-reponun-durumu-git-status/#reponun-durumu-git-status","text":"Bu noktaya kadar pek \u00e7ok kez git status yapt\u0131k. Ek birka\u00e7 parametre ile de\u011fi\u015fik \u00e7\u0131kt\u0131lar almak m\u00fcmk\u00fcn:","title":"Repo\u2019nun Durumu: git status"},{"location":"bolum-01/19-reponun-durumu-git-status/#git-status-s-ve-git-status-sb","text":"Short Status yani k\u0131saca durum bilgisi i\u00e7in kullan\u0131l\u0131r. -b bulundu\u011fun branch\u2019i de g\u00f6ster anlam\u0131ndad\u0131r: $ git status -s M file1.txt AM new-file-1.txt A new-file-2.txt ?? new-file-3.txt $ git status -sb ## master M file1.txt AM new-file-1.txt A new-file-2.txt ?? new-file-3.txt Bu tek harflerin bir anlam\u0131 var. = unmodified, bo\u015fluk karakteri, de\u011fi\u015ftirilmemi\u015f M = modified, de\u011fi\u015fiklik var A = added, eklendi yani staged D = deleted, silindi R = renamed, dosya ad\u0131 de\u011fi\u015fti C = copied, kopyaland\u0131 U = updated but unmerged, index g\u00fcncellendi ama merge edilmedi","title":"git status -s ve git status -sb"},{"location":"bolum-01/19-reponun-durumu-git-status/#git-status-ignored","text":"E\u011fer exclude edilmi\u015f, yani tan\u0131mlanan dosyalar, dizinler, ya da dosya t\u00fcrlerini GIT takibe almas\u0131n demi\u015fsek, varsa bu t\u00fcr dosyalar, status i\u00e7inde bunlar\u0131 da g\u00f6ster demektir. Dosyalar\u0131 nas\u0131l takip d\u0131\u015f\u0131nda b\u0131rak\u0131r\u0131z?","title":"git status --ignored"},{"location":"bolum-01/19-reponun-durumu-git-status/#git-status-untracked-files","text":"\u00d6rnek projede, git status dedi\u011fimiz zaman; $ git status On branch master Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) new file: new-file-1.txt new file: new-file-2.txt Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git checkout -- <file>...\" to discard changes in working directory ) modified: file1.txt modified: new-file-1.txt Untracked files: ( use \"git add <file>...\" to include in what will be committed ) new-file-3.txt test-folder/ g\u00f6r\u00fcyoruz. Bizi ilgilendiren k\u0131s\u0131m Untracked files: k\u0131sm\u0131 yani hen\u00fcz takip alt\u0131na al\u0131nmam\u0131\u015f dosyalar. Bir dosya bir de dizin g\u00f6r\u00fcyorum. Acaba bu dizin alt\u0131nda ba\u015fka dosya var m\u0131? $ git status --untracked-files On branch master Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) new file: new-file-1.txt new file: new-file-2.txt Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git checkout -- <file>...\" to discard changes in working directory ) modified: file1.txt modified: new-file-1.txt Untracked files: ( use \"git add <file>...\" to include in what will be committed ) new-file-3.txt test-folder/test-file-a.txt test-folder/test-file-b.txt test-folder/test-file-c.txt Tam \u00fc\u00e7 tane dosya varm\u0131\u015f!...","title":"git status --untracked-files"},{"location":"bolum-01/20-git-log/","text":"Log\u2019a Bak\u0131\u015f \u00dczerinden hassasiyetle durdu\u011fumuz Commit Mesaj\u0131 konusu i\u015fte bu k\u0131s\u0131mda \u00e7ok \u00f6nemli bir rol oynar \u00e7\u00fcnk\u00fc o yazd\u0131\u011f\u0131m\u0131z mesajlar, repomuzun tarih\u00e7esini g\u00f6sterir bize. git log dedi\u011fimizde; $ git log commit 5579b829b6a801f8ebd7597db7e1a9fd43f28d49 Author: U\u011fur \u00d6zy\u0131lmazel <ugurozyilmazel@gmail.com> Date: Sun Jun 25 20 :35:42 2017 +0300 file added via git add -p commit c52805a3c8f5c78588e9b7fbc2e4f1b31675d5e2 Author: U\u011fur \u00d6zy\u0131lmazel <ugurozyilmazel@gmail.com> Date: Sun Jun 25 20 :19:43 2017 +0300 added two info files for demo purposes commit bb965e45b9ca8d60de77ff066f6f4eb6ea819c97 Author: U\u011fur \u00d6zy\u0131lmazel <ugurozyilmazel@gmail.com> Date: Sun Jun 25 19 :55:24 2017 +0300 Both files are added via git add -i commit 6601df8286905fee9942dfc5fe6a36b7e95f1e7e Author: U\u011fur \u00d6zy\u0131lmazel <ugurozyilmazel@gmail.com> Date: Sun Jun 25 19 :19:40 2017 +0300 Added: readme file commit 7639a730f5c7979ca8a5ecaed3731e0e360f280a Author: U\u011fur \u00d6zy\u0131lmazel <ugurozyilmazel@gmail.com> Date: Sun Jun 25 18 :53:15 2017 +0300 [ root ] Initial commit gibi bir \u00e7\u0131kt\u0131 ile kar\u015f\u0131la\u015f\u0131r\u0131z. Burada, default olarak sondan ba\u015fa do\u011fru s\u0131ralanm\u0131\u015f bir \u015fekilde, yap\u0131lan commit, yapan, yap\u0131l\u0131\u015f tarihi ve mesaj\u0131 gibi meta bilgilerini g\u00f6r\u00fcnt\u00fcleriz. Alaca\u011f\u0131 farkl\u0131 parametrelerle \u00e7ok daha \u00f6z ve kolay anla\u015f\u0131l\u0131r bilgiler verir bize git log : $ git log --oneline 5579b829b6a8 file added via git add -p c52805a3c8f5 added two info files for demo purposes bb965e45b9ca Both files are added via git add -i 6601df828690 Added: readme file 7639a730f5c7 [ root ] Initial commit $ git log --oneline --stat 5579b829b6a8 file added via git add -p file-info-1.txt | 2 ++ 1 file changed, 2 insertions ( + ) c52805a3c8f5 added two info files for demo purposes file-info-1.txt | 1 + file-info-2.txt | 1 + 2 files changed, 2 insertions ( + ) bb965e45b9ca Both files are added via git add -i file1.txt | 0 file2.txt | 0 2 files changed, 0 insertions ( + ) , 0 deletions ( - ) 6601df828690 Added: readme file README.md | 0 1 file changed, 0 insertions ( + ) , 0 deletions ( - ) 7639a730f5c7 [ root ] Initial commit Benim bir alias\u2019\u0131m var. lg yani git lg olarak \u00e7a\u011f\u0131r\u0131yorum: $ git log --graph --decorate --oneline --all # git lg * 5579b829b6a8 ( HEAD -> master ) file added via git add -p * c52805a3c8f5 added two info files for demo purposes * bb965e45b9ca Both files are added via git add -i * 6601df828690 Added: readme file * 7639a730f5c7 [ root ] Initial commit Siz de yapabilirsiniz: $ git config --global alias.lg \"log --graph --decorate --oneline --all\" $ git help lg ` git lg ' is aliased to `log --graph --decorate --oneline --all'","title":"Log\u2019a Bak\u0131\u015f"},{"location":"bolum-01/20-git-log/#loga-baks","text":"\u00dczerinden hassasiyetle durdu\u011fumuz Commit Mesaj\u0131 konusu i\u015fte bu k\u0131s\u0131mda \u00e7ok \u00f6nemli bir rol oynar \u00e7\u00fcnk\u00fc o yazd\u0131\u011f\u0131m\u0131z mesajlar, repomuzun tarih\u00e7esini g\u00f6sterir bize. git log dedi\u011fimizde; $ git log commit 5579b829b6a801f8ebd7597db7e1a9fd43f28d49 Author: U\u011fur \u00d6zy\u0131lmazel <ugurozyilmazel@gmail.com> Date: Sun Jun 25 20 :35:42 2017 +0300 file added via git add -p commit c52805a3c8f5c78588e9b7fbc2e4f1b31675d5e2 Author: U\u011fur \u00d6zy\u0131lmazel <ugurozyilmazel@gmail.com> Date: Sun Jun 25 20 :19:43 2017 +0300 added two info files for demo purposes commit bb965e45b9ca8d60de77ff066f6f4eb6ea819c97 Author: U\u011fur \u00d6zy\u0131lmazel <ugurozyilmazel@gmail.com> Date: Sun Jun 25 19 :55:24 2017 +0300 Both files are added via git add -i commit 6601df8286905fee9942dfc5fe6a36b7e95f1e7e Author: U\u011fur \u00d6zy\u0131lmazel <ugurozyilmazel@gmail.com> Date: Sun Jun 25 19 :19:40 2017 +0300 Added: readme file commit 7639a730f5c7979ca8a5ecaed3731e0e360f280a Author: U\u011fur \u00d6zy\u0131lmazel <ugurozyilmazel@gmail.com> Date: Sun Jun 25 18 :53:15 2017 +0300 [ root ] Initial commit gibi bir \u00e7\u0131kt\u0131 ile kar\u015f\u0131la\u015f\u0131r\u0131z. Burada, default olarak sondan ba\u015fa do\u011fru s\u0131ralanm\u0131\u015f bir \u015fekilde, yap\u0131lan commit, yapan, yap\u0131l\u0131\u015f tarihi ve mesaj\u0131 gibi meta bilgilerini g\u00f6r\u00fcnt\u00fcleriz. Alaca\u011f\u0131 farkl\u0131 parametrelerle \u00e7ok daha \u00f6z ve kolay anla\u015f\u0131l\u0131r bilgiler verir bize git log : $ git log --oneline 5579b829b6a8 file added via git add -p c52805a3c8f5 added two info files for demo purposes bb965e45b9ca Both files are added via git add -i 6601df828690 Added: readme file 7639a730f5c7 [ root ] Initial commit $ git log --oneline --stat 5579b829b6a8 file added via git add -p file-info-1.txt | 2 ++ 1 file changed, 2 insertions ( + ) c52805a3c8f5 added two info files for demo purposes file-info-1.txt | 1 + file-info-2.txt | 1 + 2 files changed, 2 insertions ( + ) bb965e45b9ca Both files are added via git add -i file1.txt | 0 file2.txt | 0 2 files changed, 0 insertions ( + ) , 0 deletions ( - ) 6601df828690 Added: readme file README.md | 0 1 file changed, 0 insertions ( + ) , 0 deletions ( - ) 7639a730f5c7 [ root ] Initial commit Benim bir alias\u2019\u0131m var. lg yani git lg olarak \u00e7a\u011f\u0131r\u0131yorum: $ git log --graph --decorate --oneline --all # git lg * 5579b829b6a8 ( HEAD -> master ) file added via git add -p * c52805a3c8f5 added two info files for demo purposes * bb965e45b9ca Both files are added via git add -i * 6601df828690 Added: readme file * 7639a730f5c7 [ root ] Initial commit Siz de yapabilirsiniz: $ git config --global alias.lg \"log --graph --decorate --oneline --all\" $ git help lg ` git lg ' is aliased to `log --graph --decorate --oneline --all'","title":"Log\u2019a Bak\u0131\u015f"},{"location":"bolum-01/21-bazi-dosyalari-takip-etmemek-gitignore/","text":"Baz\u0131 Dosyalar\u0131 Takip Etmemek: .gitignore Baz\u0131 durumlarda dosya ya da dosyalar\u0131 ya da dizinleri takip d\u0131\u015f\u0131nda tutmak istersiniz. \u00d6rne\u011fin uygulaman\u0131z\u0131n log dosyalar\u0131, ya da kulland\u0131\u011f\u0131n\u0131z text edit\u00f6r\u00fc ile ilgili sadece sizi ilgilendiren dosyalar\u0131 izole etmek isteyebilirsiniz. Belki de kullan\u0131c\u0131 ad\u0131, \u015fifre, ssh bilgileri ya da SECRETS dedi\u011fimiz ENVIRONMENT de\u011fi\u015fkenlerinin ortal\u0131kta dola\u015fmamas\u0131 gerekebilir. \u0130\u015fte bu t\u00fcr durumlarda GIT\u2019e bu dosyalar\u0131 kaydetmemesini, yani takip etmemesini s\u00f6yleriz. Bu i\u015fleme ignore i\u015flemi yani g\u00f6rmezden gelme i\u015flemi denir. Ayn\u0131 konfig\u00fcrasyon dosya mant\u0131\u011f\u0131nda, ya proje bazl\u0131 local ignore dosyalar\u0131 kullan\u0131rs\u0131n\u0131z ya da kendi ~/.gitconfig dosyas\u0131nda tan\u0131mlad\u0131\u011f\u0131n\u0131z excludesfile de\u011fi\u015fkenindeki direktifleri kullan\u0131rs\u0131n\u0131z. [core] ; excludesfile = ~/.gitignore ; Ya da dizin baz\u0131nda i\u015flem yapabilirsiniz. Repo\u2019nun root\u2019unda duran .gitignore dosyas\u0131 en derindeki dizine kadar etki eder. E\u011fer isterseniz alt derinlikteki dizinlerde ba\u015fka tan\u0131mlamalar yapabilirsiniz. Yani \u015f\u00f6yle bir repo olsa: . \u251c\u2500\u2500 sub-folder \u2502 \u251c\u2500\u2500 demo.txt \u2502 \u2514\u2500\u2500 demo.xyz \u251c\u2500\u2500 file-1.txt \u251c\u2500\u2500 file-2.txt \u251c\u2500\u2500 file-3.txt \u251c\u2500\u2500 file-4.txt \u2514\u2500\u2500 file.xyz Hemen kontrol edelim durum nedir? $ git status --untracked-files On branch master Untracked files: ( use \"git add <file>...\" to include in what will be committed ) file-1.txt file-2.txt file-3.txt file-4.txt file.xyz sub-folder/demo.txt sub-folder/demo.xyz nothing added to commit but untracked files present ( use \"git add\" to track ) T\u00fcm dosyalar untracked yani eklenmeyi bekliyor. xyz extension\u2019\u0131 olan dosyalar\u0131 revizyon kontrol d\u0131\u015f\u0131nda tutal\u0131m. Bunun i\u00e7in projenin root\u2019una .gitignore dosyas\u0131 ekliyorum: $ touch .gitignore $ echo '*.xyz' >> .gitignore $ git status --untracked-files On branch master Untracked files: ( use \"git add <file>...\" to include in what will be committed ) .gitignore file-1.txt file-2.txt file-3.txt file-4.txt sub-folder/demo.txt nothing added to commit but untracked files present ( use \"git add\" to track ) Dikkat ettiyseniz art\u0131k file.xyz , sub-folder/demo.xyz dosyalar\u0131 untracked olarak g\u00f6r\u00fcnm\u00fcyor. \u00d6zellikle git status --untracked-files \u015feklinde kulland\u0131m ki alt dizinlerin alt\u0131ndaki dosyalar\u0131n da durumunu g\u00f6rebilelim. Hatta hangi dosyalar\u0131n ignore edildi\u011fini; $ git ls-files -o -i --exclude-standard file.xyz sub-folder/demo.xyz \u015feklinde de g\u00f6rebiliriz. Ben olsam bunu bir alias yapard\u0131m :) \u015eimdi dizin bazl\u0131 izolasyonu g\u00f6relim. $ mkdir no-more-php-files $ touch test.php $ touch no-more-php-files/demo.php $ touch no-more-php-files/test.rb $ tree . \u251c\u2500\u2500 no-more-php-files \u2502 \u251c\u2500\u2500 demo.php \u2502 \u2514\u2500\u2500 test.rb \u251c\u2500\u2500 sub-folder \u2502 \u251c\u2500\u2500 demo.txt \u2502 \u2514\u2500\u2500 demo.xyz \u251c\u2500\u2500 file-1.txt \u251c\u2500\u2500 file-2.txt \u251c\u2500\u2500 file-3.txt \u251c\u2500\u2500 file-4.txt \u251c\u2500\u2500 file.xyz \u2514\u2500\u2500 test.php no-more-php-files dizini alt\u0131ndaki *.php dosylar\u0131n\u0131 takip d\u0131\u015f\u0131 b\u0131rakmak istiyorum: $ echo '*.php' > no-more-php-files/.gitignore $ git status --untracked-files On branch master Untracked files: ( use \"git add <file>...\" to include in what will be committed ) .gitignore file-1.txt file-2.txt file-3.txt file-4.txt no-more-php-files/.gitignore no-more-php-files/test.rb sub-folder/demo.txt test.php nothing added to commit but untracked files present ( use \"git add\" to track ) no-more-php-files/ dizini alt\u0131ndaki demo.php izole oldu. Sa\u011flamas\u0131n\u0131 yapal\u0131m: $ git ls-files -o -i --exclude-standard file.xyz no-more-php-files/demo.php sub-folder/demo.xyz \u00d6ncelik S\u0131ras\u0131 \u00d6ncelik \u00f6nemlidir. Her \u015fey \u00f6ncelik s\u0131ras\u0131na g\u00f6re i\u015flenir. core.excludesfile konfig\u00fcrasyonunda tan\u0131ml\u0131 olanlar Repo\u2019nun root\u2019undaki .gitignore Alt dizinlerdeki .gitignore \u2019lar Diyelim ki log/ dizini var. T\u00fcm log \u00fcreten servisler buraya yaz\u0131yor. Nginx buraya access.nginx \u015feklinde yaz\u0131yor, Gunicorn ise gunicorn.log \u015feklinde yaz\u0131yor. Biz, sadece *.log yaparak gunicorn\u2019u izole edebiliriz: $ mkdir log/ && echo '*.log' > log/.gitignore $ touch log/gunicorn.log $ git ls-files -o -i --exclude-standard file.xyz log/gunicorn.log no-more-php-files/demo.php sub-folder/demo.xyz Peki, bir durum oldu, ba\u015fka bir servis daha kullanmaya ba\u015flad\u0131k ve o servis de foo.log \u015feklinde log \u00fcretiyor ve senaryo bu ya, bunu konfig\u00fcre edemiyoruz. Hatta bu dosyay\u0131 da takip etmek istiyoruz yani izole etmek istemiyoruz! Yapmam\u0131z gereken log/.gitignore dosyas\u0131na bir sat\u0131r daha eklemek: $ echo '!foo.log' >> log/.gitignore $ touch log/foo.log $ git status --untracked-files On branch master Untracked files: ( use \"git add <file>...\" to include in what will be committed ) .gitignore file-1.txt file-2.txt file-3.txt file-4.txt log/.gitignore log/foo.log no-more-php-files/.gitignore no-more-php-files/test.rb sub-folder/demo.txt test.php nothing added to commit but untracked files present ( use \"git add\" to track ) G\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi log/foo.log art\u0131k track edilmeye haz\u0131r durumda. log/.gitignore dosyas\u0131ndaki s\u0131ralama \u00e7ok \u00f6nemli: * . log !foo.log \u0130lk sat\u0131rda GIT\u2019e *.log dosyalar\u0131n\u0131 g\u00f6rme diyoruz. Hemen ikinci sat\u0131rda da foo.log dosyas\u0131n\u0131 bo\u015f ge\u00e7me, takip et diyoruz. ! tersi anlam\u0131nda. GIT ilk olarak t\u00fcm *.log dosyalar\u0131n\u0131 ignore ediyor ve sonra gelen direktife g\u00f6re foo.log dosyas\u0131n\u0131 etmiyor. E\u011fer bu ters yaz\u0131lsayd\u0131 yani; !foo.log * . log olsayd\u0131, GIT \u00f6nce foo.log dosyas\u0131n\u0131 tutacak, sonra gelen sat\u0131r T\u00dcM *.log dosyalar\u0131n\u0131 izole et emrini verece\u011fi i\u00e7in foo.log da kaynay\u0131p gidecekti. Bo\u015f Dizinler Repo\u2019da, i\u00e7inde dosya olmayan dizinler otomatik olarak g\u00f6rmezden gelinir. images/ diye bir dizinimiz olsa ve .gitignore \u2019da: images/*.jpg yazsa, images/ alt\u0131nda sadece *.jpg dosyalar\u0131 olsa, bu dizin komple ignore edilir. $ git log On branch master Untracked files: ( use \"git add <file>...\" to include in what will be committed ) .gitignore nothing added to commit but untracked files present ( use \"git add\" to track ) E\u011fer i\u00e7inde ba\u015fka bir dosya olursa, mesela images/test.png olsa; $ git log On branch master Untracked files: ( use \"git add <file>...\" to include in what will be committed ) .gitignore images/test.png nothing added to commit but untracked files present ( use \"git add\" to track ) durum de\u011fi\u015fir ve bu dizin art\u0131k izole edilmez. Bu dizin ve i\u00e7inde *.jpg olmayan dosyalar repo\u2019nun par\u00e7as\u0131 olur. Ruby on Rails d\u00fcnyas\u0131ndan g\u00f6rd\u00fc\u011f\u00fcm, ho\u015fuma giden bir takti\u011fi payla\u015fmak istiyorum. Baz\u0131 durumlarda dizini korumak gerekir, yani repo\u2019nun bir par\u00e7as\u0131 olmas\u0131 gerekir ama dizin alt\u0131ndaki belli dosyalar ya da t\u00fcm dosyalar ignore edilmi\u015f olabilir. Bu durumda !.gitkeep devreye girer. Hemen \u00f6rnek .gitignore dosyas\u0131na bakal\u0131m: /.env /bin/ *.sqlite3 /project/media/* /project/fixtures/* /project/config/settings/development.py !.gitkeep S\u0131ralama \u00f6nemli dedik. !.gitkeep mutlaka ignore edilenlerden sonra gelmeli. Bu sayede, korumak istedi\u011fim herhangi bir dizin alt\u0131na .gitkeep dosyas\u0131 koydu\u011fum an o dizin track edilmeye ba\u015flayacak ve ignore edilmesi gereken dosyalar da ignore edilecektir.","title":"Baz\u0131 Dosyalar\u0131 Takip Etmemek: `.gitignore`"},{"location":"bolum-01/21-bazi-dosyalari-takip-etmemek-gitignore/#baz-dosyalar-takip-etmemek-gitignore","text":"Baz\u0131 durumlarda dosya ya da dosyalar\u0131 ya da dizinleri takip d\u0131\u015f\u0131nda tutmak istersiniz. \u00d6rne\u011fin uygulaman\u0131z\u0131n log dosyalar\u0131, ya da kulland\u0131\u011f\u0131n\u0131z text edit\u00f6r\u00fc ile ilgili sadece sizi ilgilendiren dosyalar\u0131 izole etmek isteyebilirsiniz. Belki de kullan\u0131c\u0131 ad\u0131, \u015fifre, ssh bilgileri ya da SECRETS dedi\u011fimiz ENVIRONMENT de\u011fi\u015fkenlerinin ortal\u0131kta dola\u015fmamas\u0131 gerekebilir. \u0130\u015fte bu t\u00fcr durumlarda GIT\u2019e bu dosyalar\u0131 kaydetmemesini, yani takip etmemesini s\u00f6yleriz. Bu i\u015fleme ignore i\u015flemi yani g\u00f6rmezden gelme i\u015flemi denir. Ayn\u0131 konfig\u00fcrasyon dosya mant\u0131\u011f\u0131nda, ya proje bazl\u0131 local ignore dosyalar\u0131 kullan\u0131rs\u0131n\u0131z ya da kendi ~/.gitconfig dosyas\u0131nda tan\u0131mlad\u0131\u011f\u0131n\u0131z excludesfile de\u011fi\u015fkenindeki direktifleri kullan\u0131rs\u0131n\u0131z. [core] ; excludesfile = ~/.gitignore ; Ya da dizin baz\u0131nda i\u015flem yapabilirsiniz. Repo\u2019nun root\u2019unda duran .gitignore dosyas\u0131 en derindeki dizine kadar etki eder. E\u011fer isterseniz alt derinlikteki dizinlerde ba\u015fka tan\u0131mlamalar yapabilirsiniz. Yani \u015f\u00f6yle bir repo olsa: . \u251c\u2500\u2500 sub-folder \u2502 \u251c\u2500\u2500 demo.txt \u2502 \u2514\u2500\u2500 demo.xyz \u251c\u2500\u2500 file-1.txt \u251c\u2500\u2500 file-2.txt \u251c\u2500\u2500 file-3.txt \u251c\u2500\u2500 file-4.txt \u2514\u2500\u2500 file.xyz Hemen kontrol edelim durum nedir? $ git status --untracked-files On branch master Untracked files: ( use \"git add <file>...\" to include in what will be committed ) file-1.txt file-2.txt file-3.txt file-4.txt file.xyz sub-folder/demo.txt sub-folder/demo.xyz nothing added to commit but untracked files present ( use \"git add\" to track ) T\u00fcm dosyalar untracked yani eklenmeyi bekliyor. xyz extension\u2019\u0131 olan dosyalar\u0131 revizyon kontrol d\u0131\u015f\u0131nda tutal\u0131m. Bunun i\u00e7in projenin root\u2019una .gitignore dosyas\u0131 ekliyorum: $ touch .gitignore $ echo '*.xyz' >> .gitignore $ git status --untracked-files On branch master Untracked files: ( use \"git add <file>...\" to include in what will be committed ) .gitignore file-1.txt file-2.txt file-3.txt file-4.txt sub-folder/demo.txt nothing added to commit but untracked files present ( use \"git add\" to track ) Dikkat ettiyseniz art\u0131k file.xyz , sub-folder/demo.xyz dosyalar\u0131 untracked olarak g\u00f6r\u00fcnm\u00fcyor. \u00d6zellikle git status --untracked-files \u015feklinde kulland\u0131m ki alt dizinlerin alt\u0131ndaki dosyalar\u0131n da durumunu g\u00f6rebilelim. Hatta hangi dosyalar\u0131n ignore edildi\u011fini; $ git ls-files -o -i --exclude-standard file.xyz sub-folder/demo.xyz \u015feklinde de g\u00f6rebiliriz. Ben olsam bunu bir alias yapard\u0131m :) \u015eimdi dizin bazl\u0131 izolasyonu g\u00f6relim. $ mkdir no-more-php-files $ touch test.php $ touch no-more-php-files/demo.php $ touch no-more-php-files/test.rb $ tree . \u251c\u2500\u2500 no-more-php-files \u2502 \u251c\u2500\u2500 demo.php \u2502 \u2514\u2500\u2500 test.rb \u251c\u2500\u2500 sub-folder \u2502 \u251c\u2500\u2500 demo.txt \u2502 \u2514\u2500\u2500 demo.xyz \u251c\u2500\u2500 file-1.txt \u251c\u2500\u2500 file-2.txt \u251c\u2500\u2500 file-3.txt \u251c\u2500\u2500 file-4.txt \u251c\u2500\u2500 file.xyz \u2514\u2500\u2500 test.php no-more-php-files dizini alt\u0131ndaki *.php dosylar\u0131n\u0131 takip d\u0131\u015f\u0131 b\u0131rakmak istiyorum: $ echo '*.php' > no-more-php-files/.gitignore $ git status --untracked-files On branch master Untracked files: ( use \"git add <file>...\" to include in what will be committed ) .gitignore file-1.txt file-2.txt file-3.txt file-4.txt no-more-php-files/.gitignore no-more-php-files/test.rb sub-folder/demo.txt test.php nothing added to commit but untracked files present ( use \"git add\" to track ) no-more-php-files/ dizini alt\u0131ndaki demo.php izole oldu. Sa\u011flamas\u0131n\u0131 yapal\u0131m: $ git ls-files -o -i --exclude-standard file.xyz no-more-php-files/demo.php sub-folder/demo.xyz","title":"Baz\u0131 Dosyalar\u0131 Takip Etmemek: .gitignore"},{"location":"bolum-01/21-bazi-dosyalari-takip-etmemek-gitignore/#oncelik-sras","text":"\u00d6ncelik \u00f6nemlidir. Her \u015fey \u00f6ncelik s\u0131ras\u0131na g\u00f6re i\u015flenir. core.excludesfile konfig\u00fcrasyonunda tan\u0131ml\u0131 olanlar Repo\u2019nun root\u2019undaki .gitignore Alt dizinlerdeki .gitignore \u2019lar Diyelim ki log/ dizini var. T\u00fcm log \u00fcreten servisler buraya yaz\u0131yor. Nginx buraya access.nginx \u015feklinde yaz\u0131yor, Gunicorn ise gunicorn.log \u015feklinde yaz\u0131yor. Biz, sadece *.log yaparak gunicorn\u2019u izole edebiliriz: $ mkdir log/ && echo '*.log' > log/.gitignore $ touch log/gunicorn.log $ git ls-files -o -i --exclude-standard file.xyz log/gunicorn.log no-more-php-files/demo.php sub-folder/demo.xyz Peki, bir durum oldu, ba\u015fka bir servis daha kullanmaya ba\u015flad\u0131k ve o servis de foo.log \u015feklinde log \u00fcretiyor ve senaryo bu ya, bunu konfig\u00fcre edemiyoruz. Hatta bu dosyay\u0131 da takip etmek istiyoruz yani izole etmek istemiyoruz! Yapmam\u0131z gereken log/.gitignore dosyas\u0131na bir sat\u0131r daha eklemek: $ echo '!foo.log' >> log/.gitignore $ touch log/foo.log $ git status --untracked-files On branch master Untracked files: ( use \"git add <file>...\" to include in what will be committed ) .gitignore file-1.txt file-2.txt file-3.txt file-4.txt log/.gitignore log/foo.log no-more-php-files/.gitignore no-more-php-files/test.rb sub-folder/demo.txt test.php nothing added to commit but untracked files present ( use \"git add\" to track ) G\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi log/foo.log art\u0131k track edilmeye haz\u0131r durumda. log/.gitignore dosyas\u0131ndaki s\u0131ralama \u00e7ok \u00f6nemli: * . log !foo.log \u0130lk sat\u0131rda GIT\u2019e *.log dosyalar\u0131n\u0131 g\u00f6rme diyoruz. Hemen ikinci sat\u0131rda da foo.log dosyas\u0131n\u0131 bo\u015f ge\u00e7me, takip et diyoruz. ! tersi anlam\u0131nda. GIT ilk olarak t\u00fcm *.log dosyalar\u0131n\u0131 ignore ediyor ve sonra gelen direktife g\u00f6re foo.log dosyas\u0131n\u0131 etmiyor. E\u011fer bu ters yaz\u0131lsayd\u0131 yani; !foo.log * . log olsayd\u0131, GIT \u00f6nce foo.log dosyas\u0131n\u0131 tutacak, sonra gelen sat\u0131r T\u00dcM *.log dosyalar\u0131n\u0131 izole et emrini verece\u011fi i\u00e7in foo.log da kaynay\u0131p gidecekti.","title":"\u00d6ncelik S\u0131ras\u0131"},{"location":"bolum-01/21-bazi-dosyalari-takip-etmemek-gitignore/#bos-dizinler","text":"Repo\u2019da, i\u00e7inde dosya olmayan dizinler otomatik olarak g\u00f6rmezden gelinir. images/ diye bir dizinimiz olsa ve .gitignore \u2019da: images/*.jpg yazsa, images/ alt\u0131nda sadece *.jpg dosyalar\u0131 olsa, bu dizin komple ignore edilir. $ git log On branch master Untracked files: ( use \"git add <file>...\" to include in what will be committed ) .gitignore nothing added to commit but untracked files present ( use \"git add\" to track ) E\u011fer i\u00e7inde ba\u015fka bir dosya olursa, mesela images/test.png olsa; $ git log On branch master Untracked files: ( use \"git add <file>...\" to include in what will be committed ) .gitignore images/test.png nothing added to commit but untracked files present ( use \"git add\" to track ) durum de\u011fi\u015fir ve bu dizin art\u0131k izole edilmez. Bu dizin ve i\u00e7inde *.jpg olmayan dosyalar repo\u2019nun par\u00e7as\u0131 olur. Ruby on Rails d\u00fcnyas\u0131ndan g\u00f6rd\u00fc\u011f\u00fcm, ho\u015fuma giden bir takti\u011fi payla\u015fmak istiyorum. Baz\u0131 durumlarda dizini korumak gerekir, yani repo\u2019nun bir par\u00e7as\u0131 olmas\u0131 gerekir ama dizin alt\u0131ndaki belli dosyalar ya da t\u00fcm dosyalar ignore edilmi\u015f olabilir. Bu durumda !.gitkeep devreye girer. Hemen \u00f6rnek .gitignore dosyas\u0131na bakal\u0131m: /.env /bin/ *.sqlite3 /project/media/* /project/fixtures/* /project/config/settings/development.py !.gitkeep S\u0131ralama \u00f6nemli dedik. !.gitkeep mutlaka ignore edilenlerden sonra gelmeli. Bu sayede, korumak istedi\u011fim herhangi bir dizin alt\u0131na .gitkeep dosyas\u0131 koydu\u011fum an o dizin track edilmeye ba\u015flayacak ve ignore edilmesi gereken dosyalar da ignore edilecektir.","title":"Bo\u015f Dizinler"},{"location":"bolum-01/22-dosya-silmek-degistirmek/","text":"Dosya Silmek, Dosya Ad\u0131n\u0131 De\u011fi\u015ftirmek git mv Linus Torvalds, Linux\u2019daki dosya operasyonlar\u0131n\u0131n pek \u00e7o\u011funu GIT\u2019e entegre etmi\u015f. Nas\u0131l ki Unix/Linux\u2019da bir dosyan\u0131n ad\u0131n\u0131 de\u011fi\u015ftirmek i\u00e7in; $ mv dosya dosya_yeni_isim kullan\u0131l\u0131yorsa, ayn\u0131 i\u015fi; $ git mv dosya dosya_yeni_isim \u015feklinde yapmak m\u00fcmk\u00fcn. E\u011fer ad\u0131n\u0131 ya da yerini de\u011fi\u015ftirece\u011fimiz dosya revizyon kontrol\u00fc alt\u0131nda de\u011filse GIT size uyar\u0131 verir: $ git mv file1 file_new_1 fatal: not under version control, source = file1, destination = file_new_1 Dosya track ediliyor, unuttunuz ve mv i\u015flemini GIT \u00fczerinden de\u011fil de, i\u015fletim sistemi \u00fczerinden yapt\u0131n\u0131z. $ mv app.js application.js $ git status On branch master Changes not staged for commit: ( use \"git add/rm <file>...\" to update what will be committed ) ( use \"git checkout -- <file>...\" to discard changes in working directory ) deleted: app.js Untracked files: ( use \"git add <file>...\" to include in what will be committed ) application.js no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) GIT, app.js dosyas\u0131n\u0131n silindi\u011fini ve application.js dosyas\u0131n\u0131n takip alt\u0131nda olmayan yepyeni bir dosya oldu\u011funu d\u00fc\u015f\u00fcnd\u00fc. Hatta art\u0131k app.js dosyas\u0131n\u0131 takipten \u00e7\u0131karmam\u0131z i\u00e7in bize; $ git status : ( use \"git add/rm <file>...\" to update what will be committed ) : bile dedi... \u015eimdi biz bu de\u011fi\u015fikli\u011fi kay\u0131t alt\u0131na alal\u0131m, yani stage edelim: $ git add . $ git status On branch master Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) renamed: app.js -> application.js Ve GIT app.js dosyas\u0131n\u0131 silmedi\u011fimizi sadece ad\u0131n\u0131 de\u011fi\u015ftirdi\u011fimizi anlad\u0131. $ git status : renamed: app.js -> application.js : GIT, default olarak Similarity Index diye bir de\u011fere bakar. E\u011fer bu kar\u015f\u0131la\u015ft\u0131rma minimum 0.5 olmas\u0131 durumunda GIT bu iki dosyan\u0131n ayn\u0131 oldu\u011funa karar verir. GIT i\u00e7in \u00f6nemli olan dosya ad\u0131 de\u011fildir, dosyan\u0131n i\u00e7eri\u011fidir . git rm Ayn\u0131 mv gibi, i\u015fletim sisteminin bir kopya operasyonu da buradad\u0131r. Normalde dosya silmek i\u00e7in; $ rm file $ rm -r folder/ yapar\u0131z. Ayn\u0131 mant\u0131kta \u00f6n\u00fcne bir tek git tak\u0131yoruz: $ git rm file $ git rm -r folder E\u011fer silme i\u015fini GIT \u00fczerinden yapmazsak; $ rm index-test.html $ git status On branch master Changes not staged for commit: ( use \"git add/rm <file>...\" to update what will be committed ) ( use \"git checkout -- <file>...\" to discard changes in working directory ) deleted: index-test.html no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) Silinme durumunu GIT anlad\u0131 ama staging\u2019e atmad\u0131. Bu i\u015flemi bizim yapmam\u0131z\u0131 istiyor. E\u011fer bunu git rm ile yapsayd\u0131k; $ git rm index-test.html $ git status On branch master Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) deleted: index-test.html otomatik olarak staging\u2019e al\u0131nd\u0131. Tek yapmam\u0131z gereken \u015fey commit etmek. Silme ya da isim de\u011fi\u015ftirme i\u015flerini kulland\u0131\u011f\u0131n\u0131z IDE yerine mutlaka komut sat\u0131r\u0131ndan yapman\u0131z sizin i\u00e7in daha kolay GIT kullan\u0131m\u0131 prati\u011fi yapman\u0131z\u0131 sa\u011flar.","title":"Dosya Silmek, De\u011fi\u015ftirmek"},{"location":"bolum-01/22-dosya-silmek-degistirmek/#dosya-silmek-dosya-adn-degistirmek","text":"","title":"Dosya Silmek, Dosya Ad\u0131n\u0131 De\u011fi\u015ftirmek"},{"location":"bolum-01/22-dosya-silmek-degistirmek/#git-mv","text":"Linus Torvalds, Linux\u2019daki dosya operasyonlar\u0131n\u0131n pek \u00e7o\u011funu GIT\u2019e entegre etmi\u015f. Nas\u0131l ki Unix/Linux\u2019da bir dosyan\u0131n ad\u0131n\u0131 de\u011fi\u015ftirmek i\u00e7in; $ mv dosya dosya_yeni_isim kullan\u0131l\u0131yorsa, ayn\u0131 i\u015fi; $ git mv dosya dosya_yeni_isim \u015feklinde yapmak m\u00fcmk\u00fcn. E\u011fer ad\u0131n\u0131 ya da yerini de\u011fi\u015ftirece\u011fimiz dosya revizyon kontrol\u00fc alt\u0131nda de\u011filse GIT size uyar\u0131 verir: $ git mv file1 file_new_1 fatal: not under version control, source = file1, destination = file_new_1 Dosya track ediliyor, unuttunuz ve mv i\u015flemini GIT \u00fczerinden de\u011fil de, i\u015fletim sistemi \u00fczerinden yapt\u0131n\u0131z. $ mv app.js application.js $ git status On branch master Changes not staged for commit: ( use \"git add/rm <file>...\" to update what will be committed ) ( use \"git checkout -- <file>...\" to discard changes in working directory ) deleted: app.js Untracked files: ( use \"git add <file>...\" to include in what will be committed ) application.js no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) GIT, app.js dosyas\u0131n\u0131n silindi\u011fini ve application.js dosyas\u0131n\u0131n takip alt\u0131nda olmayan yepyeni bir dosya oldu\u011funu d\u00fc\u015f\u00fcnd\u00fc. Hatta art\u0131k app.js dosyas\u0131n\u0131 takipten \u00e7\u0131karmam\u0131z i\u00e7in bize; $ git status : ( use \"git add/rm <file>...\" to update what will be committed ) : bile dedi... \u015eimdi biz bu de\u011fi\u015fikli\u011fi kay\u0131t alt\u0131na alal\u0131m, yani stage edelim: $ git add . $ git status On branch master Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) renamed: app.js -> application.js Ve GIT app.js dosyas\u0131n\u0131 silmedi\u011fimizi sadece ad\u0131n\u0131 de\u011fi\u015ftirdi\u011fimizi anlad\u0131. $ git status : renamed: app.js -> application.js : GIT, default olarak Similarity Index diye bir de\u011fere bakar. E\u011fer bu kar\u015f\u0131la\u015ft\u0131rma minimum 0.5 olmas\u0131 durumunda GIT bu iki dosyan\u0131n ayn\u0131 oldu\u011funa karar verir. GIT i\u00e7in \u00f6nemli olan dosya ad\u0131 de\u011fildir, dosyan\u0131n i\u00e7eri\u011fidir .","title":"git mv"},{"location":"bolum-01/22-dosya-silmek-degistirmek/#git-rm","text":"Ayn\u0131 mv gibi, i\u015fletim sisteminin bir kopya operasyonu da buradad\u0131r. Normalde dosya silmek i\u00e7in; $ rm file $ rm -r folder/ yapar\u0131z. Ayn\u0131 mant\u0131kta \u00f6n\u00fcne bir tek git tak\u0131yoruz: $ git rm file $ git rm -r folder E\u011fer silme i\u015fini GIT \u00fczerinden yapmazsak; $ rm index-test.html $ git status On branch master Changes not staged for commit: ( use \"git add/rm <file>...\" to update what will be committed ) ( use \"git checkout -- <file>...\" to discard changes in working directory ) deleted: index-test.html no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) Silinme durumunu GIT anlad\u0131 ama staging\u2019e atmad\u0131. Bu i\u015flemi bizim yapmam\u0131z\u0131 istiyor. E\u011fer bunu git rm ile yapsayd\u0131k; $ git rm index-test.html $ git status On branch master Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) deleted: index-test.html otomatik olarak staging\u2019e al\u0131nd\u0131. Tek yapmam\u0131z gereken \u015fey commit etmek. Silme ya da isim de\u011fi\u015ftirme i\u015flerini kulland\u0131\u011f\u0131n\u0131z IDE yerine mutlaka komut sat\u0131r\u0131ndan yapman\u0131z sizin i\u00e7in daha kolay GIT kullan\u0131m\u0131 prati\u011fi yapman\u0131z\u0131 sa\u011flar.","title":"git rm"},{"location":"bolum-02/01-branch-ler-ile-calismak/","text":"Branch\u2019lerle \u00c7al\u0131\u015fmak GIT\u2019in bence en \u00f6nemli \u00f6zelli\u011fi branch mekanizmas\u0131d\u0131r. O an i\u00e7in \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131z yani i\u00e7inde bulundu\u011funuz branch her ne ise, o branch\u2019den ya da ba\u015fka bir branch\u2019den N tane , belkide onlarca , y\u00fczlerce kopya \u00e7\u0131kartabilirsiniz ve bu i\u015flem SIFIR MAL\u0130YETL\u0130 bir i\u015flemdir. GIT\u2019in olmad\u0131\u011f\u0131 ya da herhangi bir revizyon kontrol sisteminin olmad\u0131\u011f\u0131 bir ortamda \u00e7al\u0131\u015f\u0131yorsunuz ve projenin belli bir a\u015famas\u0131nda, bir \u00f6zelli\u011fi denemek istiyorsunuz. Ne yapars\u0131n\u0131z? Ya projeyi ya da o \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131z dosyay\u0131 kopyalars\u0131n\u0131z ve o kopya \u00fczerinde \u00e7al\u0131\u015f\u0131rs\u0131n\u0131z. D\u00fc\u015f\u00fcnsenize, 500 Megabytle\u2019\u0131k bir proje olsa, ufac\u0131k bir deneme i\u00e7in, ne olur ne olmaz i\u015fi garantiye almak i\u00e7in, komple kopya ald\u0131n\u0131z. Diskinizden 500MB daha yer i\u015fgal ettiniz. B\u00f6yle 5-10 kere kopya yapsan\u0131z Gigabyte \u2019lar seviyesinde disk alan\u0131 harcam\u0131\u015f olursunuz. Diyebilirsiniz ki; Amaaaan, ne olacak? bende Terrabyte seviyesinde disk var, 3-5 Gigabyte\u2019\u0131n laf\u0131 m\u0131 olur? Hadi diyelim yer sorunu s\u0131k\u0131nt\u0131 de\u011fil. 20 tane kopya yapt\u0131n\u0131z; proje # bu esas dizin! proje_yedek proje_yedek_1 proje_yedek_2 proje_yedek_esas_1 proje_yedek_esas_1_deneme proje_yedek_esas_1_deneme_son proje_yedek_3 proje_yedek_3_son : : gibi b\u00f6yle \u00e7\u0131lg\u0131ncas\u0131na dizinler var bilgisayar\u0131n\u0131zda. Peki neler de\u011fi\u015fti? De\u011fi\u015fen dosyalar hangileri? Bunlar\u0131n listesini tuttunuz mu? Son a\u015famadan proje/ dizinini alt\u0131na hangi dosyalar\u0131 atacaks\u0131n\u0131z? \u0130\u015fte bu ve buna benzer durumlar GIT taraf\u0131ndan s\u00fcper basit bir \u015fekilde \u00e7\u00f6z\u00fcmleniyor: $ git branch # repo\u2019daki branch\u2019leri listele * master GIT bize \u00e7al\u0131\u015ft\u0131\u011f\u0131m\u0131z kopyay\u0131, branch\u2019i s\u00f6yl\u00fcyor: master branch . Haydi deneme yapal\u0131m, akl\u0131m\u0131za bir \u015fey geldi: $ git branch idea # ad\u0131 idea olan yeni bir branch olu\u015ftur $ git branch idea * master \u0130\u00e7inde bulundu\u011fumuz branch * ile i\u015faretli. \u015eimdi yeni olu\u015fturdu\u011fumuz idea branch\u2019ine ge\u00e7elim: $ git checkout idea Switched to branch 'idea' Art\u0131k bu alanda istedi\u011fimiz her \u015feyi deneyebiliriz. Birka\u00e7 yeni dosya ekleyelim: $ touch testing-file-ab- { 1 ,2 } .sh $ git add . $ git commit -m 'added 2 test files' $ ls file-1.txt file-2.txt file-3.txt file-4.txt file.xyz log no-more-php-files sub-folder test.php testing-file-ab-1.sh testing-file-ab-2.sh $ git log --graph --decorate --oneline --all * b34155b6b819 ( HEAD -> idea ) added 2 test files * 1304ac22cd97 ( master ) Example commit * 258f67c2e2cd [ root ] Initial commit Bu \u00e7\u0131kt\u0131 bize \u015funu ifade ediyor: Toplam 3 tane commit var \u00c7al\u0131\u015ft\u0131\u011f\u0131m yer idea branch\u2019i ( HEAD ) \u015eimdi master\u2019a d\u00f6n\u00fcp orada directoy list alal\u0131m: $ git checkout master Switched to branch 'master' $ ls file-1.txt file-2.txt file-3.txt file-4.txt file.xyz log no-more-php-files sub-folder test.php \u0130ki branch aras\u0131ndaki fark ne? master branch\u2019de testing-file-ab-1.sh ve testing-file-ab-2.sh dosyalar\u0131 yok. Hatta \u015f\u00f6yle sa\u011flamas\u0131n\u0131 yapal\u0131m: $ git diff HEAD idea --name-only # git help diff testing-file-ab-1.sh testing-file-ab-2.sh idea branch\u2019inde denemelerimizi tamamlad\u0131k ve bu iki dosyay\u0131 art\u0131k master branch\u2019e almaya karar verdik. Bunu yapmak i\u00e7in y\u00f6ntemlerden bir tanesi branch\u2019leri birle\u015ftirmek yani merge etmek!","title":"Branch\u2019lerle \u00c7al\u0131\u015fmak"},{"location":"bolum-02/01-branch-ler-ile-calismak/#branchlerle-calsmak","text":"GIT\u2019in bence en \u00f6nemli \u00f6zelli\u011fi branch mekanizmas\u0131d\u0131r. O an i\u00e7in \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131z yani i\u00e7inde bulundu\u011funuz branch her ne ise, o branch\u2019den ya da ba\u015fka bir branch\u2019den N tane , belkide onlarca , y\u00fczlerce kopya \u00e7\u0131kartabilirsiniz ve bu i\u015flem SIFIR MAL\u0130YETL\u0130 bir i\u015flemdir. GIT\u2019in olmad\u0131\u011f\u0131 ya da herhangi bir revizyon kontrol sisteminin olmad\u0131\u011f\u0131 bir ortamda \u00e7al\u0131\u015f\u0131yorsunuz ve projenin belli bir a\u015famas\u0131nda, bir \u00f6zelli\u011fi denemek istiyorsunuz. Ne yapars\u0131n\u0131z? Ya projeyi ya da o \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131z dosyay\u0131 kopyalars\u0131n\u0131z ve o kopya \u00fczerinde \u00e7al\u0131\u015f\u0131rs\u0131n\u0131z. D\u00fc\u015f\u00fcnsenize, 500 Megabytle\u2019\u0131k bir proje olsa, ufac\u0131k bir deneme i\u00e7in, ne olur ne olmaz i\u015fi garantiye almak i\u00e7in, komple kopya ald\u0131n\u0131z. Diskinizden 500MB daha yer i\u015fgal ettiniz. B\u00f6yle 5-10 kere kopya yapsan\u0131z Gigabyte \u2019lar seviyesinde disk alan\u0131 harcam\u0131\u015f olursunuz. Diyebilirsiniz ki; Amaaaan, ne olacak? bende Terrabyte seviyesinde disk var, 3-5 Gigabyte\u2019\u0131n laf\u0131 m\u0131 olur? Hadi diyelim yer sorunu s\u0131k\u0131nt\u0131 de\u011fil. 20 tane kopya yapt\u0131n\u0131z; proje # bu esas dizin! proje_yedek proje_yedek_1 proje_yedek_2 proje_yedek_esas_1 proje_yedek_esas_1_deneme proje_yedek_esas_1_deneme_son proje_yedek_3 proje_yedek_3_son : : gibi b\u00f6yle \u00e7\u0131lg\u0131ncas\u0131na dizinler var bilgisayar\u0131n\u0131zda. Peki neler de\u011fi\u015fti? De\u011fi\u015fen dosyalar hangileri? Bunlar\u0131n listesini tuttunuz mu? Son a\u015famadan proje/ dizinini alt\u0131na hangi dosyalar\u0131 atacaks\u0131n\u0131z? \u0130\u015fte bu ve buna benzer durumlar GIT taraf\u0131ndan s\u00fcper basit bir \u015fekilde \u00e7\u00f6z\u00fcmleniyor: $ git branch # repo\u2019daki branch\u2019leri listele * master GIT bize \u00e7al\u0131\u015ft\u0131\u011f\u0131m\u0131z kopyay\u0131, branch\u2019i s\u00f6yl\u00fcyor: master branch . Haydi deneme yapal\u0131m, akl\u0131m\u0131za bir \u015fey geldi: $ git branch idea # ad\u0131 idea olan yeni bir branch olu\u015ftur $ git branch idea * master \u0130\u00e7inde bulundu\u011fumuz branch * ile i\u015faretli. \u015eimdi yeni olu\u015fturdu\u011fumuz idea branch\u2019ine ge\u00e7elim: $ git checkout idea Switched to branch 'idea' Art\u0131k bu alanda istedi\u011fimiz her \u015feyi deneyebiliriz. Birka\u00e7 yeni dosya ekleyelim: $ touch testing-file-ab- { 1 ,2 } .sh $ git add . $ git commit -m 'added 2 test files' $ ls file-1.txt file-2.txt file-3.txt file-4.txt file.xyz log no-more-php-files sub-folder test.php testing-file-ab-1.sh testing-file-ab-2.sh $ git log --graph --decorate --oneline --all * b34155b6b819 ( HEAD -> idea ) added 2 test files * 1304ac22cd97 ( master ) Example commit * 258f67c2e2cd [ root ] Initial commit Bu \u00e7\u0131kt\u0131 bize \u015funu ifade ediyor: Toplam 3 tane commit var \u00c7al\u0131\u015ft\u0131\u011f\u0131m yer idea branch\u2019i ( HEAD ) \u015eimdi master\u2019a d\u00f6n\u00fcp orada directoy list alal\u0131m: $ git checkout master Switched to branch 'master' $ ls file-1.txt file-2.txt file-3.txt file-4.txt file.xyz log no-more-php-files sub-folder test.php \u0130ki branch aras\u0131ndaki fark ne? master branch\u2019de testing-file-ab-1.sh ve testing-file-ab-2.sh dosyalar\u0131 yok. Hatta \u015f\u00f6yle sa\u011flamas\u0131n\u0131 yapal\u0131m: $ git diff HEAD idea --name-only # git help diff testing-file-ab-1.sh testing-file-ab-2.sh idea branch\u2019inde denemelerimizi tamamlad\u0131k ve bu iki dosyay\u0131 art\u0131k master branch\u2019e almaya karar verdik. Bunu yapmak i\u00e7in y\u00f6ntemlerden bir tanesi branch\u2019leri birle\u015ftirmek yani merge etmek!","title":"Branch\u2019lerle \u00c7al\u0131\u015fmak"},{"location":"bolum-02/02-branch-leri-birlestirmek/","text":"Branch\u2019leri Birle\u015ftirmek: git merge \u00d6nce de\u011fi\u015fiklikleri eklemek istedi\u011fimiz yani g\u00fcncelleme yapmak istedi\u011fimiz branch\u2019e ge\u00e7iyoruz. Sonra, i\u00e7inde bulundu\u011fumuz brach\u2019e birle\u015ftirmek istedi\u011fimiz branch\u2019i merge komutu ile parametre olarak ge\u00e7iyoruz. \u00d6rnek repoda, idea branch\u2019indeki de\u011fi\u015fiklikleri master branch\u2019e aktaraca\u011f\u0131z: Strateji: Fast-Forward $ git log --graph --decorate --oneline --all * 2546539c16e9 ( idea ) testing commit * b34155b6b819 added 2 test files * 1304ac22cd97 ( HEAD -> master ) Example commit * 258f67c2e2cd [ root ] Initial commit $ git checkout master # g\u00fcncelleyece\u011fimiz branch\u2019e ge\u00e7tik $ git merge idea # idea branch\u2019indeki de\u011fi\u015fiklikleri master\u2019a al Updating 1304ac22cd97..2546539c16e9 Fast-forward testing-file-ab-1.sh | 0 testing-file-ab-2.sh | 0 2 files changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 testing-file-ab-1.sh create mode 100644 testing-file-ab-2.sh \u015eimdi ne oldu ? Sat\u0131r sat\u0131r bakal\u0131m: Updating 1304ac22cd97..2546539c16e9 1304ac22cd97 bulundu\u011fumuz yerdi. 2546539c16e9 ise idea branch\u2019inin HEAD\u2019iydi. Fast-forward Kaset / teyp \u00e7alarlar\u0131 hat\u0131rlayan varsa, kaset-\u00e7alar\u2019\u0131n \u00fczerinde PLAY , STOP , RECORD , PAUSE , REW , FF gibi d\u00fc\u011fmeler vard\u0131... Kaseti ileri sarmak i\u00e7in bu FF yani Fast Forward d\u00fc\u011fmesine basard\u0131k. \u0130\u015fte GIT\u2019de aynen bu kaset kay\u0131t cihaz\u0131 gibi ileri sarma i\u015fi yapt\u0131. Log\u2019a bak\u0131ld\u0131\u011f\u0131nda, linear ( do\u011frusal ) bir durum g\u00f6r\u00fcn\u00fcyor. idea branch\u2019inde de\u011fi\u015fiklik olmas\u0131na ra\u011fmen master oldu\u011fu yerde kalm\u0131\u015f. Yani master branch\u2019de hi\u00e7bir \u015fey de\u011fi\u015fmedi\u011fi i\u00e7in GIT: Hmmm... Bu merge i\u015fini yaparken sadece pointer\u2019\u0131n yerini de\u011fi\u015ferek operasyonu tamamlayabilirim... diye d\u00fc\u015f\u00fcn\u00fcp birle\u015ftirme i\u015flemini Fast Forward stratejisi kullanarak yapt\u0131. Gayet temiz bir operasyon oldu. 2 files changed , 0 insertions ( + ), 0 deletions ( - ) Zaten hangi dosyalar oldu\u011funu da biliyorduk. Aynen tahmin etti\u011fimiz ve istedi\u011fimiz gibi oldu her \u015fey. Son durum nedir? $ git log --graph --decorate --oneline --all * 2546539c16e9 ( HEAD -> master, idea ) testing commit * b34155b6b819 added 2 test files * 1304ac22cd97 Example commit * 258f67c2e2cd [ root ] Initial commit Hem master hem de idea branch\u2019i ayn\u0131 noktay\u0131 i\u015faret ediyorlar. \u00d6nerilen, benim de hep yapt\u0131\u011f\u0131m \u015fey \u015fu; branch\u2019i merge ettikten sonra, art\u0131k o branch\u2019le i\u015fimin kalmad\u0131\u011f\u0131n\u0131 d\u00fc\u015f\u00fcn\u00fcyorum ve siliyorum: $ git branch -d idea Deleted branch idea ( was 2546539c16e9 ) . $ git branch -v * master 2546539c16e9 testing commit Strateji: Recursive \u015eimdi master branch\u2019den yeni bir branch olu\u015ftural\u0131m: $ git checkout -b development # branch\u2019i olu\u015fturup otomatik olarak checkout yapt\u0131k Switched to a new branch 'development' Bir tane yeni dosya ekleyelim: $ touch global.js && git add global.js $ git commit -m 'main js file added' [ development 7e3c5612484b ] main js file added 1 file changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 global.js $ git log --graph --decorate --oneline --all * 7e3c5612484b ( HEAD -> development ) main js file added * 2546539c16e9 ( master ) testing commit * b34155b6b819 added 2 test files * 1304ac22cd97 Example commit * 258f67c2e2cd [ root ] Initial commit Bu s\u0131rada akl\u0131m\u0131za bir \u015fey geldi, hemen master branch\u2019e d\u00f6n\u00fcp o unuttu\u011fumuz i\u015fi yapal\u0131m: $ git checkout master Switched to branch 'master' $ touch server- { 1 ,2 } .rb && git add server- { 1 ,2 } .rb $ git commit -m 'server files added' [ master e2fba879b0df ] server files added 2 files changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 server-1.rb create mode 100644 server-2.rb $ git log --graph --decorate --oneline --all * e2fba879b0df ( HEAD -> master ) server files added | * 7e3c5612484b ( development ) main js file added | / * 2546539c16e9 testing commit * b34155b6b819 added 2 test files * 1304ac22cd97 Example commit * 258f67c2e2cd [ root ] Initial commit \u0130lk kez b\u00f6yle dall\u0131 budakl\u0131 bir log ile kar\u015f\u0131 kar\u015f\u0131yay\u0131z. 2546539c16e9 numaral\u0131 commit\u2019ten iki tane t\u00fcreme olmu\u015f. Bunlar; 7e3c5612484b (development) main js file added e2fba879b0df (HEAD -> master) server files added Yani 7e3c5612484b ve e2fba879b0df komitlerinin atas\u0131: 2546539c16e9 $ git show --pretty = %h 7e3c5612484b^ # git help show 2546539c16e9 $ git show --pretty = %h e2fba879b0df^ 2546539c16e9 master branch\u2019deki 2 dosya: server-1.rb ve server-2.rb development branch\u2019inde yok development branch\u2019indeki global.js de master branch\u2019de yok Biz ne yapmak istiyoruz ? development branch\u2019deki de\u011fi\u015fiklikleri master branch\u2019e aktarmak... O zaman; $ git checkout master # master branch\u2019e ge\u00e7tik Switched to branch 'master' $ git merge development \u0130\u015fte bu noktada kar\u015f\u0131m\u0131za pat diye mesaj edit\u00f6r\u00fc \u00e7\u0131kt\u0131 ve ne g\u00f6r\u00fcyoruz? Merge branch ' development ' # Please enter a commit message to explain why this merge is necessary , # especially if it merges an updated upstream into a topic branch . # # Lines starting with ' # ' will be ignored , and an empty message aborts # the commit . Otomatik \u00fcretilmi\u015f bir commit mesaj\u0131ndan ba\u015fka bir \u015fey de\u011fil bu! GIT bize; L\u00fctfen bu birle\u015ftirmeyi a\u00e7\u0131klayan bir mesaj yaz! diye uyar\u0131da bulunuyor. Hi\u00e7bir \u015fey yazmadan kaydedip \u00e7\u0131k\u0131yorum. Mini not: E\u011fer $EDITOR environment variable atamas\u0131 yapmad\u0131ysan\u0131z ya da Temel Konfig\u00fcrasyon \u00d6\u011feleri ayar\u0131 yapmad\u0131ysan\u0131z kar\u015f\u0131n\u0131za vi text edit\u00f6r\u00fc \u00e7\u0131kacak. Bu durumda mesaj\u0131 kaydedip \u00e7\u0131kmak i\u00e7in: :wq yapman\u0131z gerekecek. Merge made by the 'recursive' strategy. global.js | 0 1 file changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 global.js $ git log --graph --decorate --oneline --all * 5424468beb69 ( HEAD -> master ) Merge branch 'development' | \\ | * 7e3c5612484b ( development ) main js file added * | e2fba879b0df server files added | / * 2546539c16e9 testing commit * b34155b6b819 added 2 test files * 1304ac22cd97 Example commit * 258f67c2e2cd [ root ] Initial commit \u0130\u015fte Recursive strateji ile yap\u0131lan merge sonucunda nur topu gibi bir merge commit \u2019imiz oldu. Buna merge bubble da denir. 5424468 beb69 ( HEAD -> master ) Merge branch ' development ' Recursive olmas\u0131n\u0131n ne s\u0131k\u0131nt\u0131s\u0131 ya da faydas\u0131 var ? \u015e\u00f6yle bakal\u0131m. Ne demi\u015ftim? \u0130\u015fimiz bitince branch\u2019i siliyoruz. Yani \u015fimdi development branch\u2019i u\u00e7urup log\u2019a tekrar bakal\u0131m: $ git branch -d development Deleted branch development ( was 7e3c5612484b ) . $ git log --graph --decorate --oneline --all * 5424468beb69 ( HEAD -> master ) Merge branch 'development' | \\ | * 7e3c5612484b main js file added * | e2fba879b0df server files added | / * 2546539c16e9 testing commit * b34155b6b819 added 2 test files * 1304ac22cd97 Example commit * 258f67c2e2cd [ root ] Initial commit Bu log\u2019a bakt\u0131\u011f\u0131m\u0131zda, ilk anda 5424468beb69 numaral\u0131 commit\u2019in bir merge commit oldu\u011funu, hatta bunun development branch\u2019inden t\u00fcredi\u011fini g\u00f6rebiliyoruz. Bu kimileri i\u00e7in faydal\u0131 olabilir. Ben linear history yani do\u011frusal, sat\u0131r sat\u0131r log g\u00f6rmeyi sevenlerdenim. Peki hemen \u015fu soru gelmeli: Peki benzer bir durumda, merge commit olmadan, linear history yapmak m\u00fcmk\u00fcn m\u00fc? Ayn\u0131 \u00f6rnekteki gibi, master ve development branch\u2019lerinde farkl\u0131l\u0131klar olacak ve biz merge commit olmadan merge yapaca\u011f\u0131z? Evet m\u00fcmk\u00fcn... Buna rebase i\u015flemi deniliyor. Yapt\u0131\u011f\u0131m\u0131z \u015fey de branch rebasing oluyor. Bu konuya gelece\u011fiz. GIT default olarak branch\u2019leri merge ederken Fast-Forward stratejisini deniyor ilk olarak. E\u011fer istersek bunu de\u011fi\u015ftirebiliriz. \u0130ster konfig\u00fcrasyon seviyesinde ister i\u015flem seviyesinde. E\u011fer default olarak branch\u2019lerin merge i\u015flemini Recursive strateji kullanarak yapmas\u0131n\u0131 isterseniz: $ git config --global merge.ff false e\u011fer i\u015flem seviyesinde yapmas\u0131n\u0131 isterseniz de: $ git checkout -b no-ff # demo ama\u00e7l\u0131 no-ff ad\u0131nda bir branch a\u00e7 ve checkout yap Switched to a new branch 'no-ff' $ touch file-for-no-ff.txt && git add file-for-no-ff.txt $ git commit -m 'no-ff commit' [ no-ff 8810d33ff41f ] no-ff commit 1 file changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 file-for-no-ff.txt $ git checkout master $ git merge no-ff --no-ff Merge made by the 'recursive' strategy. file-for-no-ff.txt | 0 1 file changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 file-for-no-ff.txt $ git log --graph --decorate --oneline --all * c83d33173bbe ( HEAD -> master ) Merge branch 'no-ff' | \\ | * 8810d33ff41f ( no-ff ) no-ff commit | / * 5424468beb69 Merge branch 'development' | \\ | * 7e3c5612484b main js file added * | e2fba879b0df server files added | / * 2546539c16e9 testing commit * b34155b6b819 added 2 test files * 1304ac22cd97 Example commit * 258f67c2e2cd [ root ] Initial commit --no-ff ile otomatik olarak birle\u015ftirme sonunda merge commit \u00fcretebilirsiniz. Hatta, \u00f6nce ne oldu\u011funa bak\u0131p sonras\u0131nda kendiniz commit\u2019i manual olarak yapabilirsiniz: $ git checkout -b no-ff-no-commit $ touch file-for-no-ff-no-commit.txt && git add $_ $ git commit -m 'commit for no-ff and no-commit demo' [ no-ff-no-commit 4d32113f1100 ] commit for no-ff and no-commit demo 1 file changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 file-for-no-ff-no-commit.txt $ git checkout master $ git merge no-ff-no-commit --no-ff --no-commit Automatic merge went well ; stopped before committing as requested --no-commit y\u00fcz\u00fcnden merge i\u015flemi tamamland\u0131 ama merge commit yap\u0131lmad\u0131. Bunu biz yapaca\u011f\u0131z. Hatta bu noktada e\u011fer gerekiyorsa ba\u015fka dosyalar eklemek \u00e7\u0131kartmak da m\u00fcmk\u00fcn: $ git status On branch master All conflicts fixed but you are still merging. ( use \"git commit\" to conclude merge ) Changes to be committed: new file: file-for-no-ff-no-commit.txt Haydi bitirelim bu i\u015flemi: $ git commit -m 'this is manual merge commit. merged with branch: no-ff-no-commit' [ master dc0c3779544f ] this is manual merge commit. merged with branch: no-ff-no-commit $ git log --graph --decorate --oneline --all * dc0c3779544f ( HEAD -> master ) this is manual merge commit. merged with branch: no-ff-no-commit | \\ | * 4d32113f1100 ( no-ff-no-commit ) commit for no-ff and no-commit demo | / * c83d33173bbe Merge branch 'no-ff' | \\ | * 8810d33ff41f ( no-ff ) no-ff commit | / * 5424468beb69 Merge branch 'development' | \\ | * 7e3c5612484b main js file added * | e2fba879b0df server files added | / * 2546539c16e9 testing commit * b34155b6b819 added 2 test files * 1304ac22cd97 Example commit * 258f67c2e2cd [ root ] Initial commit ASCII\u2019den grafik \u00e7izer gibi... Dallar budaklar hepsi burada :) Teyp Foto\u011fraf\u0131 \u00a9 vicent.zp","title":"Branch\u2019leri Birle\u015ftirmek"},{"location":"bolum-02/02-branch-leri-birlestirmek/#branchleri-birlestirmek-git-merge","text":"\u00d6nce de\u011fi\u015fiklikleri eklemek istedi\u011fimiz yani g\u00fcncelleme yapmak istedi\u011fimiz branch\u2019e ge\u00e7iyoruz. Sonra, i\u00e7inde bulundu\u011fumuz brach\u2019e birle\u015ftirmek istedi\u011fimiz branch\u2019i merge komutu ile parametre olarak ge\u00e7iyoruz. \u00d6rnek repoda, idea branch\u2019indeki de\u011fi\u015fiklikleri master branch\u2019e aktaraca\u011f\u0131z:","title":"Branch\u2019leri Birle\u015ftirmek: git merge"},{"location":"bolum-02/02-branch-leri-birlestirmek/#strateji-fast-forward","text":"$ git log --graph --decorate --oneline --all * 2546539c16e9 ( idea ) testing commit * b34155b6b819 added 2 test files * 1304ac22cd97 ( HEAD -> master ) Example commit * 258f67c2e2cd [ root ] Initial commit $ git checkout master # g\u00fcncelleyece\u011fimiz branch\u2019e ge\u00e7tik $ git merge idea # idea branch\u2019indeki de\u011fi\u015fiklikleri master\u2019a al Updating 1304ac22cd97..2546539c16e9 Fast-forward testing-file-ab-1.sh | 0 testing-file-ab-2.sh | 0 2 files changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 testing-file-ab-1.sh create mode 100644 testing-file-ab-2.sh \u015eimdi ne oldu ? Sat\u0131r sat\u0131r bakal\u0131m: Updating 1304ac22cd97..2546539c16e9 1304ac22cd97 bulundu\u011fumuz yerdi. 2546539c16e9 ise idea branch\u2019inin HEAD\u2019iydi. Fast-forward Kaset / teyp \u00e7alarlar\u0131 hat\u0131rlayan varsa, kaset-\u00e7alar\u2019\u0131n \u00fczerinde PLAY , STOP , RECORD , PAUSE , REW , FF gibi d\u00fc\u011fmeler vard\u0131... Kaseti ileri sarmak i\u00e7in bu FF yani Fast Forward d\u00fc\u011fmesine basard\u0131k. \u0130\u015fte GIT\u2019de aynen bu kaset kay\u0131t cihaz\u0131 gibi ileri sarma i\u015fi yapt\u0131. Log\u2019a bak\u0131ld\u0131\u011f\u0131nda, linear ( do\u011frusal ) bir durum g\u00f6r\u00fcn\u00fcyor. idea branch\u2019inde de\u011fi\u015fiklik olmas\u0131na ra\u011fmen master oldu\u011fu yerde kalm\u0131\u015f. Yani master branch\u2019de hi\u00e7bir \u015fey de\u011fi\u015fmedi\u011fi i\u00e7in GIT: Hmmm... Bu merge i\u015fini yaparken sadece pointer\u2019\u0131n yerini de\u011fi\u015ferek operasyonu tamamlayabilirim... diye d\u00fc\u015f\u00fcn\u00fcp birle\u015ftirme i\u015flemini Fast Forward stratejisi kullanarak yapt\u0131. Gayet temiz bir operasyon oldu. 2 files changed , 0 insertions ( + ), 0 deletions ( - ) Zaten hangi dosyalar oldu\u011funu da biliyorduk. Aynen tahmin etti\u011fimiz ve istedi\u011fimiz gibi oldu her \u015fey. Son durum nedir? $ git log --graph --decorate --oneline --all * 2546539c16e9 ( HEAD -> master, idea ) testing commit * b34155b6b819 added 2 test files * 1304ac22cd97 Example commit * 258f67c2e2cd [ root ] Initial commit Hem master hem de idea branch\u2019i ayn\u0131 noktay\u0131 i\u015faret ediyorlar. \u00d6nerilen, benim de hep yapt\u0131\u011f\u0131m \u015fey \u015fu; branch\u2019i merge ettikten sonra, art\u0131k o branch\u2019le i\u015fimin kalmad\u0131\u011f\u0131n\u0131 d\u00fc\u015f\u00fcn\u00fcyorum ve siliyorum: $ git branch -d idea Deleted branch idea ( was 2546539c16e9 ) . $ git branch -v * master 2546539c16e9 testing commit","title":"Strateji: Fast-Forward"},{"location":"bolum-02/02-branch-leri-birlestirmek/#strateji-recursive","text":"\u015eimdi master branch\u2019den yeni bir branch olu\u015ftural\u0131m: $ git checkout -b development # branch\u2019i olu\u015fturup otomatik olarak checkout yapt\u0131k Switched to a new branch 'development' Bir tane yeni dosya ekleyelim: $ touch global.js && git add global.js $ git commit -m 'main js file added' [ development 7e3c5612484b ] main js file added 1 file changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 global.js $ git log --graph --decorate --oneline --all * 7e3c5612484b ( HEAD -> development ) main js file added * 2546539c16e9 ( master ) testing commit * b34155b6b819 added 2 test files * 1304ac22cd97 Example commit * 258f67c2e2cd [ root ] Initial commit Bu s\u0131rada akl\u0131m\u0131za bir \u015fey geldi, hemen master branch\u2019e d\u00f6n\u00fcp o unuttu\u011fumuz i\u015fi yapal\u0131m: $ git checkout master Switched to branch 'master' $ touch server- { 1 ,2 } .rb && git add server- { 1 ,2 } .rb $ git commit -m 'server files added' [ master e2fba879b0df ] server files added 2 files changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 server-1.rb create mode 100644 server-2.rb $ git log --graph --decorate --oneline --all * e2fba879b0df ( HEAD -> master ) server files added | * 7e3c5612484b ( development ) main js file added | / * 2546539c16e9 testing commit * b34155b6b819 added 2 test files * 1304ac22cd97 Example commit * 258f67c2e2cd [ root ] Initial commit \u0130lk kez b\u00f6yle dall\u0131 budakl\u0131 bir log ile kar\u015f\u0131 kar\u015f\u0131yay\u0131z. 2546539c16e9 numaral\u0131 commit\u2019ten iki tane t\u00fcreme olmu\u015f. Bunlar; 7e3c5612484b (development) main js file added e2fba879b0df (HEAD -> master) server files added Yani 7e3c5612484b ve e2fba879b0df komitlerinin atas\u0131: 2546539c16e9 $ git show --pretty = %h 7e3c5612484b^ # git help show 2546539c16e9 $ git show --pretty = %h e2fba879b0df^ 2546539c16e9 master branch\u2019deki 2 dosya: server-1.rb ve server-2.rb development branch\u2019inde yok development branch\u2019indeki global.js de master branch\u2019de yok Biz ne yapmak istiyoruz ? development branch\u2019deki de\u011fi\u015fiklikleri master branch\u2019e aktarmak... O zaman; $ git checkout master # master branch\u2019e ge\u00e7tik Switched to branch 'master' $ git merge development \u0130\u015fte bu noktada kar\u015f\u0131m\u0131za pat diye mesaj edit\u00f6r\u00fc \u00e7\u0131kt\u0131 ve ne g\u00f6r\u00fcyoruz? Merge branch ' development ' # Please enter a commit message to explain why this merge is necessary , # especially if it merges an updated upstream into a topic branch . # # Lines starting with ' # ' will be ignored , and an empty message aborts # the commit . Otomatik \u00fcretilmi\u015f bir commit mesaj\u0131ndan ba\u015fka bir \u015fey de\u011fil bu! GIT bize; L\u00fctfen bu birle\u015ftirmeyi a\u00e7\u0131klayan bir mesaj yaz! diye uyar\u0131da bulunuyor. Hi\u00e7bir \u015fey yazmadan kaydedip \u00e7\u0131k\u0131yorum. Mini not: E\u011fer $EDITOR environment variable atamas\u0131 yapmad\u0131ysan\u0131z ya da Temel Konfig\u00fcrasyon \u00d6\u011feleri ayar\u0131 yapmad\u0131ysan\u0131z kar\u015f\u0131n\u0131za vi text edit\u00f6r\u00fc \u00e7\u0131kacak. Bu durumda mesaj\u0131 kaydedip \u00e7\u0131kmak i\u00e7in: :wq yapman\u0131z gerekecek. Merge made by the 'recursive' strategy. global.js | 0 1 file changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 global.js $ git log --graph --decorate --oneline --all * 5424468beb69 ( HEAD -> master ) Merge branch 'development' | \\ | * 7e3c5612484b ( development ) main js file added * | e2fba879b0df server files added | / * 2546539c16e9 testing commit * b34155b6b819 added 2 test files * 1304ac22cd97 Example commit * 258f67c2e2cd [ root ] Initial commit \u0130\u015fte Recursive strateji ile yap\u0131lan merge sonucunda nur topu gibi bir merge commit \u2019imiz oldu. Buna merge bubble da denir. 5424468 beb69 ( HEAD -> master ) Merge branch ' development ' Recursive olmas\u0131n\u0131n ne s\u0131k\u0131nt\u0131s\u0131 ya da faydas\u0131 var ? \u015e\u00f6yle bakal\u0131m. Ne demi\u015ftim? \u0130\u015fimiz bitince branch\u2019i siliyoruz. Yani \u015fimdi development branch\u2019i u\u00e7urup log\u2019a tekrar bakal\u0131m: $ git branch -d development Deleted branch development ( was 7e3c5612484b ) . $ git log --graph --decorate --oneline --all * 5424468beb69 ( HEAD -> master ) Merge branch 'development' | \\ | * 7e3c5612484b main js file added * | e2fba879b0df server files added | / * 2546539c16e9 testing commit * b34155b6b819 added 2 test files * 1304ac22cd97 Example commit * 258f67c2e2cd [ root ] Initial commit Bu log\u2019a bakt\u0131\u011f\u0131m\u0131zda, ilk anda 5424468beb69 numaral\u0131 commit\u2019in bir merge commit oldu\u011funu, hatta bunun development branch\u2019inden t\u00fcredi\u011fini g\u00f6rebiliyoruz. Bu kimileri i\u00e7in faydal\u0131 olabilir. Ben linear history yani do\u011frusal, sat\u0131r sat\u0131r log g\u00f6rmeyi sevenlerdenim. Peki hemen \u015fu soru gelmeli: Peki benzer bir durumda, merge commit olmadan, linear history yapmak m\u00fcmk\u00fcn m\u00fc? Ayn\u0131 \u00f6rnekteki gibi, master ve development branch\u2019lerinde farkl\u0131l\u0131klar olacak ve biz merge commit olmadan merge yapaca\u011f\u0131z? Evet m\u00fcmk\u00fcn... Buna rebase i\u015flemi deniliyor. Yapt\u0131\u011f\u0131m\u0131z \u015fey de branch rebasing oluyor. Bu konuya gelece\u011fiz. GIT default olarak branch\u2019leri merge ederken Fast-Forward stratejisini deniyor ilk olarak. E\u011fer istersek bunu de\u011fi\u015ftirebiliriz. \u0130ster konfig\u00fcrasyon seviyesinde ister i\u015flem seviyesinde. E\u011fer default olarak branch\u2019lerin merge i\u015flemini Recursive strateji kullanarak yapmas\u0131n\u0131 isterseniz: $ git config --global merge.ff false e\u011fer i\u015flem seviyesinde yapmas\u0131n\u0131 isterseniz de: $ git checkout -b no-ff # demo ama\u00e7l\u0131 no-ff ad\u0131nda bir branch a\u00e7 ve checkout yap Switched to a new branch 'no-ff' $ touch file-for-no-ff.txt && git add file-for-no-ff.txt $ git commit -m 'no-ff commit' [ no-ff 8810d33ff41f ] no-ff commit 1 file changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 file-for-no-ff.txt $ git checkout master $ git merge no-ff --no-ff Merge made by the 'recursive' strategy. file-for-no-ff.txt | 0 1 file changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 file-for-no-ff.txt $ git log --graph --decorate --oneline --all * c83d33173bbe ( HEAD -> master ) Merge branch 'no-ff' | \\ | * 8810d33ff41f ( no-ff ) no-ff commit | / * 5424468beb69 Merge branch 'development' | \\ | * 7e3c5612484b main js file added * | e2fba879b0df server files added | / * 2546539c16e9 testing commit * b34155b6b819 added 2 test files * 1304ac22cd97 Example commit * 258f67c2e2cd [ root ] Initial commit --no-ff ile otomatik olarak birle\u015ftirme sonunda merge commit \u00fcretebilirsiniz. Hatta, \u00f6nce ne oldu\u011funa bak\u0131p sonras\u0131nda kendiniz commit\u2019i manual olarak yapabilirsiniz: $ git checkout -b no-ff-no-commit $ touch file-for-no-ff-no-commit.txt && git add $_ $ git commit -m 'commit for no-ff and no-commit demo' [ no-ff-no-commit 4d32113f1100 ] commit for no-ff and no-commit demo 1 file changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 file-for-no-ff-no-commit.txt $ git checkout master $ git merge no-ff-no-commit --no-ff --no-commit Automatic merge went well ; stopped before committing as requested --no-commit y\u00fcz\u00fcnden merge i\u015flemi tamamland\u0131 ama merge commit yap\u0131lmad\u0131. Bunu biz yapaca\u011f\u0131z. Hatta bu noktada e\u011fer gerekiyorsa ba\u015fka dosyalar eklemek \u00e7\u0131kartmak da m\u00fcmk\u00fcn: $ git status On branch master All conflicts fixed but you are still merging. ( use \"git commit\" to conclude merge ) Changes to be committed: new file: file-for-no-ff-no-commit.txt Haydi bitirelim bu i\u015flemi: $ git commit -m 'this is manual merge commit. merged with branch: no-ff-no-commit' [ master dc0c3779544f ] this is manual merge commit. merged with branch: no-ff-no-commit $ git log --graph --decorate --oneline --all * dc0c3779544f ( HEAD -> master ) this is manual merge commit. merged with branch: no-ff-no-commit | \\ | * 4d32113f1100 ( no-ff-no-commit ) commit for no-ff and no-commit demo | / * c83d33173bbe Merge branch 'no-ff' | \\ | * 8810d33ff41f ( no-ff ) no-ff commit | / * 5424468beb69 Merge branch 'development' | \\ | * 7e3c5612484b main js file added * | e2fba879b0df server files added | / * 2546539c16e9 testing commit * b34155b6b819 added 2 test files * 1304ac22cd97 Example commit * 258f67c2e2cd [ root ] Initial commit ASCII\u2019den grafik \u00e7izer gibi... Dallar budaklar hepsi burada :) Teyp Foto\u011fraf\u0131 \u00a9 vicent.zp","title":"Strateji: Recursive"},{"location":"bolum-02/03-branch-lerin-cakismasi-conflict/","text":"Branch\u2019lerin \u00c7ak\u0131\u015fmas\u0131: Conflict Ayn\u0131 dosyalar \u00fczerinde \u00e7al\u0131\u015f\u0131nca conflict yan\u0131 \u00e7ak\u0131\u015fma ya\u015famak ka\u00e7\u0131n\u0131lmazd\u0131r. Duruma g\u00f6re bu \u00e7ak\u0131\u015fmalar \u00e7ok can s\u0131k\u0131c\u0131 olabilir. Bazen kabus haline bile d\u00f6n\u00fc\u015febilir. Halk aras\u0131nda conflict yemek olarak da bilinir. GIT sa\u011f olsun \u00e7\u00f6z\u00fcm y\u00f6ntemlerini \u00f6\u011frenip ( daha do\u011frusu kaydedip ) benzer \u00e7ak\u0131\u015fma oldu\u011fu zaman otomatik olarak \u00e7\u00f6zebiliyor. Bunun i\u00e7in konfig\u00fcrasyon ayar\u0131 yapmak gerekiyor: $ git config --global rerere.enabled true rerere yi ilk g\u00f6rd\u00fc\u011f\u00fcmde bir Be\u015fikta\u015f taraftar\u0131 olarak akl\u0131ma Galatasaray\u2019\u0131n rerere rarara tezah\u00fcrat\u0131 gelmi\u015fti :) Ne demek rerere ? Reuse Recorded Resolution ( of conflicted merges ) yani: branch\u2019leri merge ederken ( birle\u015ftirirken ) kaydedilen \u00e7\u00f6z\u00fcm \u015feklini, ayn\u0131 \u00e7ak\u0131\u015fma oldu\u011fu an tekrar kullan. Bir web uygulamas\u0131 yap\u0131yoruz, yeni bir feature geli\u015ftirmek istiyoruz. Uygulama yap\u0131s\u0131 a\u015fa\u011f\u0131daki gibi: . \u251c\u2500\u2500 public \u2502 \u251c\u2500\u2500 css \u2502 \u2502 \u2514\u2500\u2500 application.css \u2502 \u251c\u2500\u2500 images \u2502 \u2502 \u2514\u2500\u2500 photo.jpg \u2502 \u2514\u2500\u2500 js \u2502 \u2514\u2500\u2500 global.js \u2514\u2500\u2500 index.html Yeni feature i\u00e7in bir branch a\u00e7\u0131p \u00e7al\u0131\u015fal\u0131m: $ git checkout -b feature Switched to a new branch 'feature' # index.html\u2019e eklemeler yapt\u0131k, css\u2019e ek yapt\u0131k $ git add . $ git commit -m 'Footer information added' [ feature c5084b90ab6e ] Footer information added 2 files changed, 6 insertions ( + ) $ git log --graph --decorate --oneline --all * c5084b90ab6e ( HEAD -> feature ) Footer information added * 60ee4fd58668 ( master ) Demo site initiated * fea8c5d8e385 [ root ] Initial commit \u015eimdi tam bu esnada, bir telefon geldi ve hemen master branch\u2019deki index.html dosyas\u0131nda bir de\u011fi\u015fiklik yapman\u0131z gerekti\u011fini \u00f6\u011frendiniz. Hen\u00fcz geli\u015ftirmekte oldu\u011funuz \u015feyi de bitirmediniz... Ne laz\u0131m? $ git checkout master # gereken de\u011fi\u015fikli\u011fi yapt\u0131n\u0131z: $ git diff head:index.html feature:index.html diff --git a/index.html b/index.html index d62d871da6ef..4fbafe3dfd2b 100644 --- a/index.html +++ b/index.html @@ -9,8 +9,10 @@ </head> <body> <header> - <h1>Demo Site 2017 </h1> + <h1>Demo Site</h1> </header> - <script src = \"public/js/global-1.js\" ></script> + + <footer>Address information</footer> + <script src = \"public/js/global.js\" ></script> </body> </html> \u015eimdi commit edelim: $ git add . $ git commit -m 'added: 2017 text to heading1 and some other fixes' [ master 8f9bb3474c79 ] added: 2017 text to heading1 and some other fixes 1 file changed, 1 insertion ( + ) , 1 deletion ( - ) Log\u2019da durum nas\u0131l g\u00f6r\u00fcn\u00fcyor ? $ git log --graph --decorate --oneline --all * 8f9bb3474c79 ( HEAD -> master ) added: 2017 text to heading1 and some other fixes | * c5084b90ab6e ( feature ) Footer information added | / * 60ee4fd58668 Demo site initiated * fea8c5d8e385 [ root ] Initial commit 60ee4fd58668 ID\u2019li commit\u2019den t\u00fcreyen 2 commit var: c5084b90ab6e 8f9bb3474c79 Bu iki commit aras\u0131ndaki fark ne? $ git diff c5084b90ab6e 8f9bb3474c79 # feature ile HEAD aras\u0131ndaki diff bu yani $ git diff feature HEAD # ayn\u0131 \u015fey \u00e7\u0131kt\u0131s\u0131: diff --git a/index.html b/index.html index 4fbafe3dfd2b..d62d871da6ef 100644 --- a/index.html +++ b/index.html @@ -9,10 +9,8 @@ </head> <body> <header> - <h1>Demo Site</h1> + <h1>Demo Site 2017</h1> </header> - - <footer>Address information</footer> - <script src=\"public/js/global.js\"></script> + <script src=\"public/js/global-1.js\"></script> </body> </html> diff --git a/public/css/application.css b/public/css/application.css index e166ec262bd6..018697659236 100644 --- a/public/css/application.css +++ b/public/css/application.css @@ -9,8 +9,4 @@ h1, h2, h3, h4, h5, h6 { color: #b65; padding: 0; margin: 1rem 0; -} - -footer { - color: #a73; } \\ No newline at end of file Birinde olan di\u011ferinde yok ya da di\u011ferinde tamamen ba\u015fka bir \u015fey var. Biz master branch\u2019deyiz ve git merge feature dedi\u011fimiz an conflict yiyece\u011fimiz ap a\u00e7\u0131k ortada. Kar\u015f\u0131m\u0131zdaki se\u00e7enekler: Kodu yazan biz oldu\u011fumuz i\u00e7in ne olmas\u0131 gerekti\u011fini biliyoruz, elle gereken d\u00fczeltmeleri yapaca\u011f\u0131z. Do\u011fru olan k\u0131s\u0131m master branch\u2019deki k\u0131s\u0131m, esas olan o! Do\u011fru olan k\u0131s\u0131m feature branch\u2019deki k\u0131s\u0131m, esas olan o! Amaaaan, bana ne ya, vazge\u00e7iyorum! kim merge ederse etsin! :) Haydi o zaman: $ git merge feature Auto-merging index.html CONFLICT ( content ) : Merge conflict in index.html Recorded preimage for 'index.html' Automatic merge failed ; fix conflicts and then commit the result. Evet, GIT, otomatik olarak index.html \u2019i merge etmek istedi ama bu dosyada merge conflict ile kar\u015f\u0131la\u015ft\u0131 ve olas\u0131 \u00e7\u00f6z\u00fcm i\u00e7in kayda ge\u00e7ti: Recorded preimage for ' index.html ' Durum ne? $ git status On branch master You have unmerged paths. ( fix conflicts and run \"git commit\" ) ( use \"git merge --abort\" to abort the merge ) Changes to be committed: modified: public/css/application.css Unmerged paths: ( use \"git add <file>...\" to mark resolution ) both modified: index.html public/css/application.css bunda s\u0131k\u0131nt\u0131 yok. both modified ne demek? Kelime anlam\u0131 olarak her ikisi de de\u011fi\u015fti gibi bir \u015fey \u00e7\u0131k\u0131yor. Burada bahsi ge\u00e7enler kim? Az \u00f6nce kar\u015f\u0131m\u0131zdaki se\u00e7eneklerden bahsetmi\u015ftim. Do\u011fru olan k\u0131s\u0131m master ya da feature ... GIT, birle\u015ftirmek istedi\u011fimiz branch\u2019i ONLARIN yani theirs , i\u00e7inde bulundu\u011fumuz branch\u2019i de B\u0130Z\u0130M yani ours olarak s\u0131n\u0131fland\u0131r\u0131yor. Bir \u015feyin both modified olmas\u0131 demek, hem bizim taraf\u0131n, hem de onlar\u0131n taraf\u0131n modifiye olmas\u0131 demek. \u015eimdi son se\u00e7enek olan: Bana ne! vazge\u00e7tim i yapal\u0131m. master branch i\u00e7in ( \u015fu an master branch\u2019deyiz ya ) merge\u2019den \u00f6nceki son commit hangisiydi? $ git reset --hard 8f9bb3474c79 HEAD is now at 8f9bb3474c79 added: 2017 text to heading1 and some other fixes Her commit, asl\u0131nda zaman\u0131n foto\u011fraf\u0131n\u0131 \u00e7ekmek de\u011fil miydi? \u015eimdi o an\u2019a geri d\u00f6nd\u00fck. \u00d6zellikle --hard kulland\u0131k ki geride bir \u015fey kalmas\u0131n. git reset konusunu ileride g\u00f6rece\u011fiz. \u015eimdi tekrar merge edip conflict\u2019e geri d\u00f6nelim: $ git merge feature Auto-merging index.html CONFLICT ( content ) : Merge conflict in index.html Recorded preimage for 'index.html' Automatic merge failed ; fix conflicts and then commit the result. \u015eu sorunlu index.html \u2019e bir bakal\u0131m: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1\" > < title > Demo site </ title > < link rel = \"stylesheet\" href = \"public/css/application.css\" type = \"text/css\" /> </ head > < body > < header > < h1 > Demo Site 2017 </ h1 > </ header > <<<<<< < HEAD < script src = \"public/js/global-1.js\" ></ script > ======= < footer > Address information </ footer > < script src = \"public/js/global.js\" ></ script > >>>>>>> feature </ body > </ html > Bu dosyada dikkat edece\u011fimiz \u015feylerin ba\u015f\u0131nda gelen i\u015faretle: <<<<<<< >>>>>>> ======= <<<<<<< HEAD diye ifade i\u015faretlenen yer master branch\u2019de olan fark. Yani B\u0130Z\u0130M yani --ours . >>>>>>> feature diye i\u015faretlenen yer feature branch\u2019de olan fark. Yani ONLARIN yani --theirs . ======= ise ayra\u00e7. \u00dcst ile alt k\u0131sm\u0131 ay\u0131r\u0131yor. \u015eimdi; Ya do\u011fru olan\u0131, olmas\u0131 gerekeni biz bildi\u011fimiz i\u00e7in kendi kafam\u0131za g\u00f6re gereken de\u011fi\u015fikli\u011fi yapaca\u011f\u0131z Ya do\u011fru olan bizim taraf, onlar\u0131n taraf\u0131 unut diyece\u011fiz Ya da do\u011frusu onlar\u0131n, bizimkini \u00e7\u00f6pe at diyece\u011fiz Bu \u00f6rnek s\u00fcper basit ve \u00e7ok rahat anla\u015f\u0131l\u0131yor ne oldu\u011fu. Daha karma\u015f\u0131k kompleks projelerde bu i\u015fi \u00e7\u00f6zmek i\u00e7in 3.parti ara\u00e7lar kullanmak bile gerekebiliyor. Ben \"esas olan onlar\u0131n yapt\u0131klar\u0131d\u0131r, ben zaten uydurdum\" diyorum ve; $ git checkout --theirs index.html # yok bizimkini al: git checkout --ours index.html $ cat index.html ve; <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1\" > < title > Demo site </ title > < link rel = \"stylesheet\" href = \"public/css/application.css\" type = \"text/css\" /> </ head > < body > < header > < h1 > Demo Site </ h1 > </ header > < footer > Address information </ footer > < script src = \"public/js/global.js\" ></ script > </ body > </ html > checkout sadece branch\u2019ler aras\u0131 ge\u00e7i\u015f d\u0131\u015f\u0131nda da ba\u015fka fonksiyonlar\u0131 olan bir komut. git reset konusunda de\u011finece\u011fim ama h\u0131zl\u0131ca; git checkout -- DOSYA asl\u0131nda git status komutundan a\u015fina oldu\u011fumuz bir \u015fey: Changes not staged for commit : ( use \" git checkout -- <file>... \" to discard changes in working directory ) derki: to discard changes in working directory yani, \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131z yerde/dizinde/branch\u2019de, yapt\u0131\u011f\u0131n\u0131z de\u011fi\u015fiklikleri \u00e7\u00f6pe atmak i\u00e7in: git checkout -- <file>... kullan\u0131n! Bu mini nottan sonra bari en az\u0131ndan 2017 \u2019yi ekleyeyim: $ git add index.html $ git status On branch master All conflicts fixed but you are still merging. ( use \"git commit\" to conclude merge ) Changes to be committed: modified: index.html modified: public/css/application.css Art\u0131k commit yapacak k\u0131vama geldi: $ git commit -m 'fixed: funny merge conflict' Recorded resolution for 'index.html' . [ master d1d1d648b034 ] fixed: funny merge conflict Dikkat ettiyseniz GIT hemen atlad\u0131 ve bu \u00e7\u00f6z\u00fcm\u00fc \u00f6\u011frendi\u011fini s\u00f6yledi hemen. Log ne alemde? $ git log --graph --decorate --oneline --all * d1d1d648b034 ( HEAD -> master ) fixed: funny merge conflict | \\ | * c5084b90ab6e ( feature ) Footer information added * | 8f9bb3474c79 added: 2017 text to heading1 and some other fixes | / * 60ee4fd58668 Demo site initiated * fea8c5d8e385 [ root ] Initial commit Nur topu gibi bir merge bubble/commit ile i\u015fimize devam ediyoruz. Hemen master\u2019daki g\u00fcncellemeleri feature\u2019a da alal\u0131m, i\u015fimiz hen\u00fcz bitmedi: $ git checkout feature Switched to branch 'feature' $ git merge master Updating c5084b90ab6e..d1d1d648b034 Fast-forward index.html | 2 +- 1 file changed, 1 insertion ( + ) , 1 deletion ( - ) Temiz bir Fast-forward oldu. Log ne durumda? $ git log --graph --decorate --oneline --all * d1d1d648b034 ( HEAD -> feature, master ) fixed: funny merge conflict | \\ | * c5084b90ab6e Footer information added * | 8f9bb3474c79 added: 2017 text to heading1 and some other fixes | / * 60ee4fd58668 Demo site initiated * fea8c5d8e385 [ root ] Initial commit Bulundu\u011fumuz yer yani HEAD , hem master \u2019\u0131 hem de feature \u2019\u0131 i\u015faret ediyor. History\u2019nin ( yani log\u2019un ) temiz olmas\u0131 i\u00e7in bize ne laz\u0131m ?","title":"Branch\u2019lerin \u00c7ak\u0131\u015fmas\u0131: Conflict"},{"location":"bolum-02/03-branch-lerin-cakismasi-conflict/#branchlerin-caksmas-conflict","text":"Ayn\u0131 dosyalar \u00fczerinde \u00e7al\u0131\u015f\u0131nca conflict yan\u0131 \u00e7ak\u0131\u015fma ya\u015famak ka\u00e7\u0131n\u0131lmazd\u0131r. Duruma g\u00f6re bu \u00e7ak\u0131\u015fmalar \u00e7ok can s\u0131k\u0131c\u0131 olabilir. Bazen kabus haline bile d\u00f6n\u00fc\u015febilir. Halk aras\u0131nda conflict yemek olarak da bilinir. GIT sa\u011f olsun \u00e7\u00f6z\u00fcm y\u00f6ntemlerini \u00f6\u011frenip ( daha do\u011frusu kaydedip ) benzer \u00e7ak\u0131\u015fma oldu\u011fu zaman otomatik olarak \u00e7\u00f6zebiliyor. Bunun i\u00e7in konfig\u00fcrasyon ayar\u0131 yapmak gerekiyor: $ git config --global rerere.enabled true rerere yi ilk g\u00f6rd\u00fc\u011f\u00fcmde bir Be\u015fikta\u015f taraftar\u0131 olarak akl\u0131ma Galatasaray\u2019\u0131n rerere rarara tezah\u00fcrat\u0131 gelmi\u015fti :) Ne demek rerere ? Reuse Recorded Resolution ( of conflicted merges ) yani: branch\u2019leri merge ederken ( birle\u015ftirirken ) kaydedilen \u00e7\u00f6z\u00fcm \u015feklini, ayn\u0131 \u00e7ak\u0131\u015fma oldu\u011fu an tekrar kullan. Bir web uygulamas\u0131 yap\u0131yoruz, yeni bir feature geli\u015ftirmek istiyoruz. Uygulama yap\u0131s\u0131 a\u015fa\u011f\u0131daki gibi: . \u251c\u2500\u2500 public \u2502 \u251c\u2500\u2500 css \u2502 \u2502 \u2514\u2500\u2500 application.css \u2502 \u251c\u2500\u2500 images \u2502 \u2502 \u2514\u2500\u2500 photo.jpg \u2502 \u2514\u2500\u2500 js \u2502 \u2514\u2500\u2500 global.js \u2514\u2500\u2500 index.html Yeni feature i\u00e7in bir branch a\u00e7\u0131p \u00e7al\u0131\u015fal\u0131m: $ git checkout -b feature Switched to a new branch 'feature' # index.html\u2019e eklemeler yapt\u0131k, css\u2019e ek yapt\u0131k $ git add . $ git commit -m 'Footer information added' [ feature c5084b90ab6e ] Footer information added 2 files changed, 6 insertions ( + ) $ git log --graph --decorate --oneline --all * c5084b90ab6e ( HEAD -> feature ) Footer information added * 60ee4fd58668 ( master ) Demo site initiated * fea8c5d8e385 [ root ] Initial commit \u015eimdi tam bu esnada, bir telefon geldi ve hemen master branch\u2019deki index.html dosyas\u0131nda bir de\u011fi\u015fiklik yapman\u0131z gerekti\u011fini \u00f6\u011frendiniz. Hen\u00fcz geli\u015ftirmekte oldu\u011funuz \u015feyi de bitirmediniz... Ne laz\u0131m? $ git checkout master # gereken de\u011fi\u015fikli\u011fi yapt\u0131n\u0131z: $ git diff head:index.html feature:index.html diff --git a/index.html b/index.html index d62d871da6ef..4fbafe3dfd2b 100644 --- a/index.html +++ b/index.html @@ -9,8 +9,10 @@ </head> <body> <header> - <h1>Demo Site 2017 </h1> + <h1>Demo Site</h1> </header> - <script src = \"public/js/global-1.js\" ></script> + + <footer>Address information</footer> + <script src = \"public/js/global.js\" ></script> </body> </html> \u015eimdi commit edelim: $ git add . $ git commit -m 'added: 2017 text to heading1 and some other fixes' [ master 8f9bb3474c79 ] added: 2017 text to heading1 and some other fixes 1 file changed, 1 insertion ( + ) , 1 deletion ( - ) Log\u2019da durum nas\u0131l g\u00f6r\u00fcn\u00fcyor ? $ git log --graph --decorate --oneline --all * 8f9bb3474c79 ( HEAD -> master ) added: 2017 text to heading1 and some other fixes | * c5084b90ab6e ( feature ) Footer information added | / * 60ee4fd58668 Demo site initiated * fea8c5d8e385 [ root ] Initial commit 60ee4fd58668 ID\u2019li commit\u2019den t\u00fcreyen 2 commit var: c5084b90ab6e 8f9bb3474c79 Bu iki commit aras\u0131ndaki fark ne? $ git diff c5084b90ab6e 8f9bb3474c79 # feature ile HEAD aras\u0131ndaki diff bu yani $ git diff feature HEAD # ayn\u0131 \u015fey \u00e7\u0131kt\u0131s\u0131: diff --git a/index.html b/index.html index 4fbafe3dfd2b..d62d871da6ef 100644 --- a/index.html +++ b/index.html @@ -9,10 +9,8 @@ </head> <body> <header> - <h1>Demo Site</h1> + <h1>Demo Site 2017</h1> </header> - - <footer>Address information</footer> - <script src=\"public/js/global.js\"></script> + <script src=\"public/js/global-1.js\"></script> </body> </html> diff --git a/public/css/application.css b/public/css/application.css index e166ec262bd6..018697659236 100644 --- a/public/css/application.css +++ b/public/css/application.css @@ -9,8 +9,4 @@ h1, h2, h3, h4, h5, h6 { color: #b65; padding: 0; margin: 1rem 0; -} - -footer { - color: #a73; } \\ No newline at end of file Birinde olan di\u011ferinde yok ya da di\u011ferinde tamamen ba\u015fka bir \u015fey var. Biz master branch\u2019deyiz ve git merge feature dedi\u011fimiz an conflict yiyece\u011fimiz ap a\u00e7\u0131k ortada. Kar\u015f\u0131m\u0131zdaki se\u00e7enekler: Kodu yazan biz oldu\u011fumuz i\u00e7in ne olmas\u0131 gerekti\u011fini biliyoruz, elle gereken d\u00fczeltmeleri yapaca\u011f\u0131z. Do\u011fru olan k\u0131s\u0131m master branch\u2019deki k\u0131s\u0131m, esas olan o! Do\u011fru olan k\u0131s\u0131m feature branch\u2019deki k\u0131s\u0131m, esas olan o! Amaaaan, bana ne ya, vazge\u00e7iyorum! kim merge ederse etsin! :) Haydi o zaman: $ git merge feature Auto-merging index.html CONFLICT ( content ) : Merge conflict in index.html Recorded preimage for 'index.html' Automatic merge failed ; fix conflicts and then commit the result. Evet, GIT, otomatik olarak index.html \u2019i merge etmek istedi ama bu dosyada merge conflict ile kar\u015f\u0131la\u015ft\u0131 ve olas\u0131 \u00e7\u00f6z\u00fcm i\u00e7in kayda ge\u00e7ti: Recorded preimage for ' index.html ' Durum ne? $ git status On branch master You have unmerged paths. ( fix conflicts and run \"git commit\" ) ( use \"git merge --abort\" to abort the merge ) Changes to be committed: modified: public/css/application.css Unmerged paths: ( use \"git add <file>...\" to mark resolution ) both modified: index.html public/css/application.css bunda s\u0131k\u0131nt\u0131 yok. both modified ne demek? Kelime anlam\u0131 olarak her ikisi de de\u011fi\u015fti gibi bir \u015fey \u00e7\u0131k\u0131yor. Burada bahsi ge\u00e7enler kim? Az \u00f6nce kar\u015f\u0131m\u0131zdaki se\u00e7eneklerden bahsetmi\u015ftim. Do\u011fru olan k\u0131s\u0131m master ya da feature ... GIT, birle\u015ftirmek istedi\u011fimiz branch\u2019i ONLARIN yani theirs , i\u00e7inde bulundu\u011fumuz branch\u2019i de B\u0130Z\u0130M yani ours olarak s\u0131n\u0131fland\u0131r\u0131yor. Bir \u015feyin both modified olmas\u0131 demek, hem bizim taraf\u0131n, hem de onlar\u0131n taraf\u0131n modifiye olmas\u0131 demek. \u015eimdi son se\u00e7enek olan: Bana ne! vazge\u00e7tim i yapal\u0131m. master branch i\u00e7in ( \u015fu an master branch\u2019deyiz ya ) merge\u2019den \u00f6nceki son commit hangisiydi? $ git reset --hard 8f9bb3474c79 HEAD is now at 8f9bb3474c79 added: 2017 text to heading1 and some other fixes Her commit, asl\u0131nda zaman\u0131n foto\u011fraf\u0131n\u0131 \u00e7ekmek de\u011fil miydi? \u015eimdi o an\u2019a geri d\u00f6nd\u00fck. \u00d6zellikle --hard kulland\u0131k ki geride bir \u015fey kalmas\u0131n. git reset konusunu ileride g\u00f6rece\u011fiz. \u015eimdi tekrar merge edip conflict\u2019e geri d\u00f6nelim: $ git merge feature Auto-merging index.html CONFLICT ( content ) : Merge conflict in index.html Recorded preimage for 'index.html' Automatic merge failed ; fix conflicts and then commit the result. \u015eu sorunlu index.html \u2019e bir bakal\u0131m: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1\" > < title > Demo site </ title > < link rel = \"stylesheet\" href = \"public/css/application.css\" type = \"text/css\" /> </ head > < body > < header > < h1 > Demo Site 2017 </ h1 > </ header > <<<<<< < HEAD < script src = \"public/js/global-1.js\" ></ script > ======= < footer > Address information </ footer > < script src = \"public/js/global.js\" ></ script > >>>>>>> feature </ body > </ html > Bu dosyada dikkat edece\u011fimiz \u015feylerin ba\u015f\u0131nda gelen i\u015faretle: <<<<<<< >>>>>>> ======= <<<<<<< HEAD diye ifade i\u015faretlenen yer master branch\u2019de olan fark. Yani B\u0130Z\u0130M yani --ours . >>>>>>> feature diye i\u015faretlenen yer feature branch\u2019de olan fark. Yani ONLARIN yani --theirs . ======= ise ayra\u00e7. \u00dcst ile alt k\u0131sm\u0131 ay\u0131r\u0131yor. \u015eimdi; Ya do\u011fru olan\u0131, olmas\u0131 gerekeni biz bildi\u011fimiz i\u00e7in kendi kafam\u0131za g\u00f6re gereken de\u011fi\u015fikli\u011fi yapaca\u011f\u0131z Ya do\u011fru olan bizim taraf, onlar\u0131n taraf\u0131 unut diyece\u011fiz Ya da do\u011frusu onlar\u0131n, bizimkini \u00e7\u00f6pe at diyece\u011fiz Bu \u00f6rnek s\u00fcper basit ve \u00e7ok rahat anla\u015f\u0131l\u0131yor ne oldu\u011fu. Daha karma\u015f\u0131k kompleks projelerde bu i\u015fi \u00e7\u00f6zmek i\u00e7in 3.parti ara\u00e7lar kullanmak bile gerekebiliyor. Ben \"esas olan onlar\u0131n yapt\u0131klar\u0131d\u0131r, ben zaten uydurdum\" diyorum ve; $ git checkout --theirs index.html # yok bizimkini al: git checkout --ours index.html $ cat index.html ve; <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1\" > < title > Demo site </ title > < link rel = \"stylesheet\" href = \"public/css/application.css\" type = \"text/css\" /> </ head > < body > < header > < h1 > Demo Site </ h1 > </ header > < footer > Address information </ footer > < script src = \"public/js/global.js\" ></ script > </ body > </ html > checkout sadece branch\u2019ler aras\u0131 ge\u00e7i\u015f d\u0131\u015f\u0131nda da ba\u015fka fonksiyonlar\u0131 olan bir komut. git reset konusunda de\u011finece\u011fim ama h\u0131zl\u0131ca; git checkout -- DOSYA asl\u0131nda git status komutundan a\u015fina oldu\u011fumuz bir \u015fey: Changes not staged for commit : ( use \" git checkout -- <file>... \" to discard changes in working directory ) derki: to discard changes in working directory yani, \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131z yerde/dizinde/branch\u2019de, yapt\u0131\u011f\u0131n\u0131z de\u011fi\u015fiklikleri \u00e7\u00f6pe atmak i\u00e7in: git checkout -- <file>... kullan\u0131n! Bu mini nottan sonra bari en az\u0131ndan 2017 \u2019yi ekleyeyim: $ git add index.html $ git status On branch master All conflicts fixed but you are still merging. ( use \"git commit\" to conclude merge ) Changes to be committed: modified: index.html modified: public/css/application.css Art\u0131k commit yapacak k\u0131vama geldi: $ git commit -m 'fixed: funny merge conflict' Recorded resolution for 'index.html' . [ master d1d1d648b034 ] fixed: funny merge conflict Dikkat ettiyseniz GIT hemen atlad\u0131 ve bu \u00e7\u00f6z\u00fcm\u00fc \u00f6\u011frendi\u011fini s\u00f6yledi hemen. Log ne alemde? $ git log --graph --decorate --oneline --all * d1d1d648b034 ( HEAD -> master ) fixed: funny merge conflict | \\ | * c5084b90ab6e ( feature ) Footer information added * | 8f9bb3474c79 added: 2017 text to heading1 and some other fixes | / * 60ee4fd58668 Demo site initiated * fea8c5d8e385 [ root ] Initial commit Nur topu gibi bir merge bubble/commit ile i\u015fimize devam ediyoruz. Hemen master\u2019daki g\u00fcncellemeleri feature\u2019a da alal\u0131m, i\u015fimiz hen\u00fcz bitmedi: $ git checkout feature Switched to branch 'feature' $ git merge master Updating c5084b90ab6e..d1d1d648b034 Fast-forward index.html | 2 +- 1 file changed, 1 insertion ( + ) , 1 deletion ( - ) Temiz bir Fast-forward oldu. Log ne durumda? $ git log --graph --decorate --oneline --all * d1d1d648b034 ( HEAD -> feature, master ) fixed: funny merge conflict | \\ | * c5084b90ab6e Footer information added * | 8f9bb3474c79 added: 2017 text to heading1 and some other fixes | / * 60ee4fd58668 Demo site initiated * fea8c5d8e385 [ root ] Initial commit Bulundu\u011fumuz yer yani HEAD , hem master \u2019\u0131 hem de feature \u2019\u0131 i\u015faret ediyor. History\u2019nin ( yani log\u2019un ) temiz olmas\u0131 i\u00e7in bize ne laz\u0131m ?","title":"Branch\u2019lerin \u00c7ak\u0131\u015fmas\u0131: Conflict"},{"location":"bolum-02/04-branch-leri-birlestirmek-rebasing/","text":"Branch\u2019leri Birle\u015ftirmek: git rebase @wip","title":"Branch\u2019leri Birle\u015ftirmek: `rebasing`"},{"location":"bolum-02/04-branch-leri-birlestirmek-rebasing/#branchleri-birlestirmek-git-rebase","text":"@wip","title":"Branch\u2019leri Birle\u015ftirmek: git rebase"},{"location":"bolum-02/05-branch-rebase-sirasinda-conflict/","text":"Branch Rebase S\u0131ras\u0131nda \u00c7ak\u0131\u015fma: Rebase Conflict @wip","title":"Branch Rebase S\u0131ras\u0131nda \u00c7ak\u0131\u015fma: **Rebase Conflict**"},{"location":"bolum-02/05-branch-rebase-sirasinda-conflict/#branch-rebase-srasnda-caksma-rebase-conflict","text":"@wip","title":"Branch Rebase S\u0131ras\u0131nda \u00c7ak\u0131\u015fma: Rebase Conflict"},{"location":"bolum-02/06-degisiklikleri-goruntulemek-git-diff/","text":"De\u011fi\u015fiklikleri G\u00f6r\u00fcnt\u00fclemek: git diff @wip git whatchanged @wip","title":"De\u011fi\u015fiklikleri G\u00f6r\u00fcnt\u00fclemek: `git diff`"},{"location":"bolum-02/06-degisiklikleri-goruntulemek-git-diff/#degisiklikleri-goruntulemek-git-diff","text":"@wip","title":"De\u011fi\u015fiklikleri G\u00f6r\u00fcnt\u00fclemek: git diff"},{"location":"bolum-02/06-degisiklikleri-goruntulemek-git-diff/#git-whatchanged","text":"@wip","title":"git whatchanged"},{"location":"bolum-02/07-etiketlemek-nedir-git-tag/","text":"Etiketlemek Nedir?: git tag @wip","title":"Etiketlemek Nedir?: `git tag`"},{"location":"bolum-02/07-etiketlemek-nedir-git-tag/#etiketlemek-nedir-git-tag","text":"@wip","title":"Etiketlemek Nedir?: git tag"},{"location":"bolum-03/01-commit-leri-birlestirmek-interactive-rebasing/","text":"Commit\u2019leri Birle\u015ftirmek: Interactive Rebasing @wip","title":"Commit\u2019leri Birle\u015ftirmek: Interactive Rebasing"},{"location":"bolum-03/01-commit-leri-birlestirmek-interactive-rebasing/#commitleri-birlestirmek-interactive-rebasing","text":"@wip","title":"Commit\u2019leri Birle\u015ftirmek: Interactive Rebasing"},{"location":"bolum-03/02-commit-leri-bolmek/","text":"Commit\u2019leri B\u00f6lmek @wip","title":"Commit\u2019leri B\u00f6lmek"},{"location":"bolum-03/02-commit-leri-bolmek/#commitleri-bolmek","text":"@wip","title":"Commit\u2019leri B\u00f6lmek"},{"location":"bolum-03/03-cimbizla-commit-i-almak-cherry-picking/","text":"C\u0131mb\u0131zla Commit\u2019i Almak: Cherry Picking @wip","title":"C\u0131mb\u0131zla Commit\u2019i Almak: Cherry Picking"},{"location":"bolum-03/03-cimbizla-commit-i-almak-cherry-picking/#cmbzla-commiti-almak-cherry-picking","text":"@wip","title":"C\u0131mb\u0131zla Commit\u2019i Almak: Cherry Picking"},{"location":"bolum-03/04-hatalari-islemleri-geri-almak-ya-da-vazgecmek/","text":"Hatalar\u0131 \u0130\u015flemleri Geri Almak ya da Vazge\u00e7mek git reset @wip --amend @wip git revert @wip Anl\u0131k De\u011fi\u015fiklikleri Saklamak: git stash @wip","title":"Hatalar\u0131 \u0130\u015flemleri Geri Almak ya da Vazge\u00e7mek: `reset revert amend`"},{"location":"bolum-03/04-hatalari-islemleri-geri-almak-ya-da-vazgecmek/#hatalar-islemleri-geri-almak-ya-da-vazgecmek","text":"","title":"Hatalar\u0131 \u0130\u015flemleri Geri Almak ya da Vazge\u00e7mek"},{"location":"bolum-03/04-hatalari-islemleri-geri-almak-ya-da-vazgecmek/#git-reset","text":"@wip","title":"git reset"},{"location":"bolum-03/04-hatalari-islemleri-geri-almak-ya-da-vazgecmek/#-amend","text":"@wip","title":"--amend"},{"location":"bolum-03/04-hatalari-islemleri-geri-almak-ya-da-vazgecmek/#git-revert","text":"@wip","title":"git revert"},{"location":"bolum-03/04-hatalari-islemleri-geri-almak-ya-da-vazgecmek/#anlk-degisiklikleri-saklamak-git-stash","text":"@wip","title":"Anl\u0131k De\u011fi\u015fiklikleri Saklamak: git stash"},{"location":"bolum-03/05-commit-notu/","text":"Commit\u2019e Not Eklemek @wip","title":"Commit\u2019e Not Eklemek"},{"location":"bolum-03/05-commit-notu/#commite-not-eklemek","text":"@wip","title":"Commit\u2019e Not Eklemek"},{"location":"bolum-03/06-hersey-kayit-altinda-git-reflog/","text":"Her \u015fey Kay\u0131t Alt\u0131nda! En az 90 g\u00fcn: git reflog @wip","title":"Her \u015fey Kay\u0131t Alt\u0131nda! En az 90 g\u00fcn: `git reflog`"},{"location":"bolum-03/06-hersey-kayit-altinda-git-reflog/#her-sey-kayt-altnda-en-az-90-gun-git-reflog","text":"@wip","title":"Her \u015fey Kay\u0131t Alt\u0131nda! En az 90 g\u00fcn: git reflog"},{"location":"bolum-04/01-remote-nedir/","text":"Remote Kavram\u0131 Nedir? Remote\u2019larla \u00c7al\u0131\u015fmak @wip Tracking Branch / Upstream @wip git fetch ile git pull Fark\u0131 ? @wip git pull --rebase ile git pull Fark\u0131 ? @wip","title":"Remote Kavram\u0131 Nedir? Remote\u2019larla \u00c7al\u0131\u015fmak"},{"location":"bolum-04/01-remote-nedir/#remote-kavram-nedir-remotelarla-calsmak","text":"@wip","title":"Remote Kavram\u0131 Nedir? Remote\u2019larla \u00c7al\u0131\u015fmak"},{"location":"bolum-04/01-remote-nedir/#tracking-branch-upstream","text":"@wip","title":"Tracking Branch / Upstream"},{"location":"bolum-04/01-remote-nedir/#git-fetch-ile-git-pull-fark","text":"@wip","title":"git fetch ile git pull Fark\u0131 ?"},{"location":"bolum-04/01-remote-nedir/#git-pull-rebase-ile-git-pull-fark","text":"@wip","title":"git pull --rebase ile git pull Fark\u0131 ?"},{"location":"bolum-04/02-kendi-git-reponuzu-yapin/","text":"Kendi GIT Reponuzu Yap\u0131n! @wip","title":"Kendi GIT Reponuzu Yap\u0131n!"},{"location":"bolum-04/02-kendi-git-reponuzu-yapin/#kendi-git-reponuzu-yapn","text":"@wip","title":"Kendi GIT Reponuzu Yap\u0131n!"},{"location":"bolum-04/03-cloud-git-sunucu-platformlar%C4%B1/","text":"GitHub, BitBucket ve GitLab ile \u00c7al\u0131\u015fmak @wip","title":"GitHub, BitBucket ve GitLab ile \u00c7al\u0131\u015fmak"},{"location":"bolum-04/03-cloud-git-sunucu-platformlar%C4%B1/#github-bitbucket-ve-gitlab-ile-calsmak","text":"@wip","title":"GitHub, BitBucket ve GitLab ile \u00c7al\u0131\u015fmak"},{"location":"bolum-04/04-repo-icinde-repo-git-submodule/","text":"Repo i\u00e7inde Repo: git submodule @wip","title":"Repo i\u00e7inde Repo: `git submodule`"},{"location":"bolum-04/04-repo-icinde-repo-git-submodule/#repo-icinde-repo-git-submodule","text":"@wip","title":"Repo i\u00e7inde Repo: git submodule"},{"location":"bolum-05/01-git-hook-lari/","text":"Commit \u00d6ncesi ya da Sonras\u0131 Otomasyonu: Hook\u2019lar @wip","title":"Commit \u00d6ncesi ya da Sonras\u0131 Otomasyonu: Hook\u2019lar"},{"location":"bolum-05/01-git-hook-lari/#commit-oncesi-ya-da-sonras-otomasyonu-hooklar","text":"@wip","title":"Commit \u00d6ncesi ya da Sonras\u0131 Otomasyonu: Hook\u2019lar"},{"location":"bolum-05/02-bundle-nedir/","text":"Bundle Nedir? @wip","title":"Bundle Nedir?"},{"location":"bolum-05/02-bundle-nedir/#bundle-nedir","text":"@wip","title":"Bundle Nedir?"},{"location":"bolum-05/03-git-gpg-ile-imza/","text":"Commit\u2019inizi \u0130mzalay\u0131n @wip","title":"Commit\u2019inizi \u0130mzalay\u0131n"},{"location":"bolum-05/03-git-gpg-ile-imza/#commitinizi-imzalayn","text":"@wip","title":"Commit\u2019inizi \u0130mzalay\u0131n"},{"location":"bolum-05/04-revizyonlari-sorgulamak/","text":"Revizyonlar\u0131 Sorgulamak @wip","title":"Revizyonlar\u0131 Sorgulamak"},{"location":"bolum-05/04-revizyonlari-sorgulamak/#revizyonlar-sorgulamak","text":"@wip","title":"Revizyonlar\u0131 Sorgulamak"},{"location":"bolum-05/05-commit-leri-sorgulamak/","text":"Commit\u2019leri Sorgulamak git blame @wip","title":"Commit\u2019leri Sorgulamak: `blame`"},{"location":"bolum-05/05-commit-leri-sorgulamak/#commitleri-sorgulamak","text":"","title":"Commit\u2019leri Sorgulamak"},{"location":"bolum-05/05-commit-leri-sorgulamak/#git-blame","text":"@wip","title":"git blame"},{"location":"bolum-05/06-git-bisect-nedir/","text":"Bisect Nedir? @wip","title":"Bisect Nedir?"},{"location":"bolum-05/06-git-bisect-nedir/#bisect-nedir","text":"@wip","title":"Bisect Nedir?"},{"location":"bolum-05/07-git-araclari/","text":"Yard\u0131mc\u0131 Ara\u00e7lar tig @wip git extras @wip","title":"Yard\u0131mc\u0131 Ara\u00e7lar"},{"location":"bolum-05/07-git-araclari/#yardmc-araclar","text":"","title":"Yard\u0131mc\u0131 Ara\u00e7lar"},{"location":"bolum-05/07-git-araclari/#tig","text":"@wip","title":"tig"},{"location":"bolum-05/07-git-araclari/#git-extras","text":"@wip","title":"git extras"},{"location":"bolum-05/08-faydali-ipculari/","text":"Faydal\u0131 \u0130pu\u00e7lar\u0131 @wip","title":"Faydal\u0131 \u0130pu\u00e7lar\u0131"},{"location":"bolum-05/08-faydali-ipculari/#faydal-ipuclar","text":"@wip","title":"Faydal\u0131 \u0130pu\u00e7lar\u0131"}]}